<!DOCTYPE html>
<!-- saved from url=(0091)file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc 0.8.1">
<title>metadynminer API documentation</title>
<meta name="description" content="Metadynminer is a package designed to help you analyse output HILLS files from PLUMED metadynamics simulations …">
<link href="./metadynminer API documentation_files/normalize.min.css" rel="stylesheet">
<link href="./metadynminer API documentation_files/sanitize.min.css" rel="stylesheet">
<link href="./metadynminer API documentation_files/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>metadynminer</code></h1>
</header>
<section id="section-intro">
<p>Metadynminer is a package designed to help you analyse output HILLS files from PLUMED metadynamics simulations. </p>
<p>It is based on Metadynminer package for R programming language, but it is not just a port from R to Python, as it is updated and improved in many aspects. It supports HILLS files with one, two or three collective variables. </p>
<p>All built-in functions can be easily customized with many parameters. You can learn more about that later in the documentation. There are also functions allowing you to enhance your presentation with animations of your 3D FES or remove a CV from existing FES. </p>
<p>Installation:</p>
<pre><code class="language-bash hljs">pip install metadynminer
</code></pre>
<p>or</p>
<pre><code class="language-bash hljs">conda install -c jan8be metadynminer
</code></pre>
<p>Sample code:</p>
<p>Load your HILLS file: </p>
<pre><code class="language-python hljs">hillsfile = metadynminer.Hills(name=<span class="hljs-string">"HILLS"</span>, periodic=[<span class="hljs-keyword">True</span>,<span class="hljs-keyword">True</span>])
</code></pre>
<p>Compute the free energy surface using the fast Bias Sum Algorithm:</p>
<pre><code class="language-python hljs">fes = metadynminer.Fes(hillsfile)
</code></pre>
<p>You can also use slower (but exact) algorithm to sum the hills and compute the free energy surface
with the option original=True. This algorithm was checked and it gives the same result
(to the machine level precision) as the PLUMED sum_hills function (for plumed v2.8.0).</p>
<pre><code class="language-python hljs">fes2 = metadynminer.Fes(hillsfile, original=<span class="hljs-keyword">True</span>)
</code></pre>
<p>Visualize the free energy surface and save the picture to a file:</p>
<pre><code class="language-python hljs">fes.plot(png_name=<span class="hljs-string">"fes.png"</span>)
</code></pre>
<p>Find local minima on the FES, print them and save FES with minima as a picture:</p>
<pre><code class="language-python hljs">minima = metadynminer.Minima(fes)
print(minima.minima)
minima.plot(png_name=<span class="hljs-string">"fes.png"</span>)
</code></pre>
<p>You can also plot free energy profile to see, how the differences between each minima were evolving
during the simulation. Convergence in the free energy profile suggests, that the resulting free energy surface converged to correct values.</p>
<pre><code class="language-python hljs">fep = metadynminer.FEProfile(minima, hillsfile)
fep.plot()
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-string">"""
Metadynminer is a package designed to help you analyse output HILLS files from PLUMED metadynamics simulations. 

It is based on Metadynminer package for R programming language, but it is not just a port from R to Python, as it is updated and improved in many aspects. It supports HILLS files with one, two or three collective variables. 

All built-in functions can be easily customized with many parameters. You can learn more about that later in the documentation. There are also functions allowing you to enhance your presentation with animations of your 3D FES or remove a CV from existing FES. 

Installation:

```bash
pip install metadynminer
```
or
```bash
conda install -c jan8be metadynminer
```


Sample code:

Load your HILLS file: 
```python
hillsfile = metadynminer.Hills(name="HILLS", periodic=[True,True])
```

Compute the free energy surface using the fast Bias Sum Algorithm:
```python
fes = metadynminer.Fes(hillsfile)
```

You can also use slower (but exact) algorithm to sum the hills and compute the free energy surface 
with the option original=True. This algorithm was checked and it gives the same result 
(to the machine level precision) as the PLUMED sum_hills function (for plumed v2.8.0).
```python
fes2 = metadynminer.Fes(hillsfile, original=True)
```

Visualize the free energy surface and save the picture to a file:
```python
fes.plot(png_name="fes.png")
```

Find local minima on the FES, print them and save FES with minima as a picture:
```python
minima = metadynminer.Minima(fes)
print(minima.minima)
minima.plot(png_name="fes.png")
```

You can also plot free energy profile to see, how the differences between each minima were evolving 
during the simulation. Convergence in the free energy profile suggests, that the resulting free energy surface converged to correct values.
```python
fep = metadynminer.FEProfile(minima, hillsfile)
fep.plot()
```
"""</span>

name = <span class="hljs-string">"metadynminer"</span>
__version__ = <span class="hljs-string">"0.2.3"</span>
__author__ = <span class="hljs-string">'Jan Beránek'</span>

__pdoc__ = {}

<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">except</span>:
    print(<span class="hljs-string">"Error while loading numpy"</span>)
    exit()
<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">except</span>:
    print(<span class="hljs-string">"Error while loading matplotlib pyplot"</span>)
    exit()
<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> colormaps <span class="hljs-keyword">as</span> cm
<span class="hljs-keyword">except</span>:
    print(<span class="hljs-string">"Error while loading matplotlib colormaps"</span>)
    exit()
<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">except</span>:
    print(<span class="hljs-string">"Error while loading pandas"</span>)
    exit()
<span class="hljs-keyword">try</span>:
    <span class="hljs-keyword">import</span> pyvista <span class="hljs-keyword">as</span> pv
<span class="hljs-keyword">except</span>:
    print(<span class="hljs-string">"Error while loading pyvista"</span>)
    exit()

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hills</span>:</span>
    <span class="hljs-string">"""
    Object of Hills class are created for loading HILLS files, and obtaining the necessary information from them. 

    Hills files are loaded with command:
    ```python
    hillsfile = metadynminer.Hills(name="HILLS", periodic=[False,False])
    ```
    
    optional parameters:
    
    * name (default="HILLS") = string with name of HILLS file
    
    * ignoretime (default=True) = boolean, if set to False, it will save the time in the HILLS file;
                                if set to True, and timestep is not set, 
                                        each time value will be incremented by the same amount as the time of the first step.
                                        
    * timestep = numeric value of the time difference between hills, in picoseconds
    
    * periodic (default=[False, False]) = list of boolean values telling which CV is periodic.
    
    * cv1per, cv2per, cv3per (defaults = [-numpy.pi, numpy.pi]) = List of two numeric values defining the periodicity of given CV. 
                                        Has to be provided for each periodic CV.
    """</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name=<span class="hljs-string">"HILLS"</span>, encoding=<span class="hljs-string">"utf8"</span>, ignoretime=True, periodic=[False, False], 
                 cv1per=[-np.pi, np.pi],cv2per=[-np.pi, np.pi],cv3per=[-np.pi, np.pi], timestep=None)</span>:</span>
        self.read(name, encoding, ignoretime, periodic, 
                 cv1per=[-np.pi, np.pi],cv2per=[-np.pi, np.pi],cv3per=[-np.pi, np.pi], timestep=timestep)
        self.hillsfilename = name
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span><span class="hljs-params">(self, name=<span class="hljs-string">"HILLS"</span>, encoding=<span class="hljs-string">"utf8"</span>, ignoretime=True, periodic=None, 
                 cv1per=[-np.pi, np.pi],cv2per=[-np.pi, np.pi],cv3per=[-np.pi, np.pi], timestep=None)</span>:</span>
        <span class="hljs-keyword">with</span> open(name, <span class="hljs-string">'r'</span>, encoding=encoding) <span class="hljs-keyword">as</span> hillsfile:
            lines = hillsfile.readlines()
        columns = lines[<span class="hljs-number">0</span>].split() 
        number_of_columns_head = len(columns) - <span class="hljs-number">2</span>
        
        <span class="hljs-keyword">if</span> number_of_columns_head == <span class="hljs-number">5</span>:
            self.cvs = <span class="hljs-number">1</span>
            self.cv1_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">3</span>]
            <span class="hljs-keyword">if</span> periodic == <span class="hljs-keyword">None</span>:
                periodic = list(<span class="hljs-keyword">False</span>)
            
            self.periodic = list(periodic[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>])
            self.cv1per = cv1per

        <span class="hljs-keyword">elif</span> number_of_columns_head == <span class="hljs-number">7</span>:
            self.cvs = <span class="hljs-number">2</span>
            self.cv1_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">3</span>]
            self.cv2_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">4</span>]
            <span class="hljs-keyword">if</span> len(periodic) == <span class="hljs-number">2</span>:
                self.periodic = periodic[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]
                self.cv1per = cv1per
                self.cv2per = cv2per
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">f"Error: argument 'periodic' has wrong number of parameters(<span class="hljs-subst">{len(periodic)}</span>)"</span>)
        <span class="hljs-keyword">elif</span> number_of_columns_head == <span class="hljs-number">9</span>:
            self.cvs = <span class="hljs-number">3</span>
            self.cv1_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">3</span>]
            self.cv2_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">4</span>]
            self.cv3_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">5</span>]
            
            <span class="hljs-keyword">if</span> len(periodic) == <span class="hljs-number">3</span>:
                self.periodic = periodic[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]
                self.cv1per = cv1per
                self.cv2per = cv2per
                self.cv3per = cv3per
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">f"Argument 'periodic' has wrong number of parameters(<span class="hljs-subst">{len(periodic)}</span>)"</span>)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Unexpected number of columns in provided HILLS file."</span>)
        
        
        <span class="hljs-keyword">if</span> ignoretime:
            <span class="hljs-keyword">if</span> timestep != <span class="hljs-keyword">None</span>:
                dt = timestep
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(lines)):
                    <span class="hljs-keyword">if</span> lines[line][<span class="hljs-number">0</span>] != <span class="hljs-string">"#"</span>:
                        dt = round(float(lines[line].split()[<span class="hljs-number">0</span>]),<span class="hljs-number">14</span>)
                        <span class="hljs-keyword">break</span>
        t = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(lines)):
            <span class="hljs-keyword">if</span> lines[line][<span class="hljs-number">0</span>] != <span class="hljs-string">"#"</span>:
                t += <span class="hljs-number">1</span> 
                <span class="hljs-keyword">if</span> t == <span class="hljs-number">1</span>:
                    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
                        self.sigma1 = float(lines[line].split()[<span class="hljs-number">2</span>])
                        self.biasf = float(lines[line].split()[<span class="hljs-number">4</span>])
                    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
                        self.sigma1 = float(lines[line].split()[<span class="hljs-number">3</span>])
                        self.sigma2 = float(lines[line].split()[<span class="hljs-number">4</span>])
                        self.biasf = float(lines[line].split()[<span class="hljs-number">6</span>])
                    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
                        self.sigma1 = float(lines[line].split()[<span class="hljs-number">4</span>])
                        self.sigma2 = float(lines[line].split()[<span class="hljs-number">5</span>])
                        self.sigma3 = float(lines[line].split()[<span class="hljs-number">6</span>])
                        self.biasf = float(lines[line].split()[<span class="hljs-number">8</span>])
                    self.hills = [lines[line].split()]
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> len(lines[line].split()) == <span class="hljs-number">5</span>:
                        self.hills.append(lines[line].split())
                        <span class="hljs-keyword">if</span> ignoretime:
                            self.hills[t<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] = t*dt
                    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> len(lines[line].split()) == <span class="hljs-number">7</span>:
                        self.hills.append(lines[line].split())
                        <span class="hljs-keyword">if</span> ignoretime:
                            self.hills[t<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] = t*dt
                    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> len(lines[line].split()) == <span class="hljs-number">9</span>:
                        self.hills.append(lines[line].split())
                        <span class="hljs-keyword">if</span> ignoretime:
                            self.hills[t<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] = t*dt
                    
        
        self.hills = np.array(self.hills, dtype=np.double)
                
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            self.cv1 = self.hills[:,<span class="hljs-number">1</span>]
            self.sigma1 = self.hills[:,<span class="hljs-number">2</span>]
            self.heights = self.hills[:,<span class="hljs-number">3</span>]
            self.biasf = self.hills[:,<span class="hljs-number">4</span>]
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            self.cv1 = self.hills[:,<span class="hljs-number">1</span>]
            self.cv2 = self.hills[:,<span class="hljs-number">2</span>]
            self.sigma1 = self.hills[:,<span class="hljs-number">3</span>]
            self.sigma2 = self.hills[:,<span class="hljs-number">4</span>]
            self.heights = self.hills[:,<span class="hljs-number">5</span>]
            self.biasf = self.hills[:,<span class="hljs-number">6</span>]
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            self.cv1 = self.hills[:,<span class="hljs-number">1</span>]
            self.cv2 = self.hills[:,<span class="hljs-number">2</span>]
            self.cv3 = self.hills[:,<span class="hljs-number">3</span>]
            self.sigma1 = self.hills[:,<span class="hljs-number">4</span>]
            self.sigma2 = self.hills[:,<span class="hljs-number">5</span>]
            self.sigma3 = self.hills[:,<span class="hljs-number">6</span>]
            self.heights = self.hills[:,<span class="hljs-number">7</span>]
            self.biasf = self.hills[:,<span class="hljs-number">8</span>]
        <span class="hljs-keyword">return</span> self
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv1</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv1
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv2</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv2
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv3</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv3
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv1per</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv1per
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv2per</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv2per
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv3per</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv3per
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_periodic</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.periodic
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv1_name</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv1_name
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv2_name</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv2_name
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv3_name</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv3_name
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_hills</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.hills
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_number_of_cvs</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cvs
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sigma1</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.sigma1
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sigma2</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.sigma2
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sigma3</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.sigma3
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_heights</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span>(self.heights)
    
    __pdoc__[<span class="hljs-string">"Hills.get_cv1"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv2"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv3"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv1per"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv2per"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv3per"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv1_name"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv2_name"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv3_name"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_periodic"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_hills"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_number_of_cvs"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_sigma1"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_sigma2"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_sigma3"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_heights"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.read"</span>] = <span class="hljs-keyword">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_heights</span><span class="hljs-params">(self, png_name=None, energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>])</span>:</span>
        <span class="hljs-string">"""
        Function used to visualize heights of the hills that were added during the simulation. 
        
        ```python
        hillsfile.plot_heights(png_name="picture.png")
        ```
        
        Parameters:
        
        * png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.
        
        * energy_unit (default="kJ/mol") = String, used in description of the y axis
        
        * xlabel, ylabel = Strings, if provided, they will be used as labels for the graphs
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        """</span>
        plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
        plt.plot(range(len(self.heights)), self.heights)
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            plt.xlabel(<span class="hljs-string">f'time (ps)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.xlabel(xlabel, size=label_size)
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            plt.ylabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.ylabel(ylabel, size=label_size)
            
        <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
            plt.savefig(png_name)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fes</span>:</span> 
    <span class="hljs-string">"""
    Object of this class is created to compute the free energy surface corresponding to the provided Hills object. 
    Command:
    ```python
    fes = metadynminer.Fes(hills=hillsfile)
    ```
    parameters:
    
    * hills = Hills object
    
    * resolution (default=256) = should be positive integer, controls the resolution of FES
    
    * original (default=False) = boolean, if False, FES will be calculated using very fast, but not
    'exact' Bias Sum Algorithm
                                        if True, FES will be calculated with slower algorithm, but it will be exactly the same as FES calculated 
                                        with PLUMED sum_hills function
                                        
    * cv1range, cv2range, cv3range = lists of two numbers, defining lower and upper bound of the respective CV (in the units of the CVs)
    """</span>
    
    __pdoc__[<span class="hljs-string">"Fes.makefes"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Fes.makefes2"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Fes.set_fes"</span>] = <span class="hljs-keyword">False</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, hills=None, resolution=<span class="hljs-number">256</span>, original=False, \
                 calculate_new_fes=True, cv1range=None, cv2range=None, cv3range=None, \
                 time_min=<span class="hljs-number">0</span>, time_max=None)</span>:</span>
        self.res = resolution
        self.cv1range = cv1range
        self.cv2range = cv2range
        self.cv3range = cv3range
        <span class="hljs-keyword">if</span> hills != <span class="hljs-keyword">None</span>:
            self.hills = hills
            self.cvs = hills.get_number_of_cvs()
            self.heights = hills.get_heights()
            self.periodic = hills.get_periodic()
            self.biasf = hills.biasf
            
            <span class="hljs-keyword">if</span> cv1range!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> len(cv1range) != <span class="hljs-number">2</span>:
                print(<span class="hljs-string">"Error: You have to specify CV1 range as a list of two values. "</span>)
            <span class="hljs-keyword">if</span> cv2range!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> len(cv2range) != <span class="hljs-number">2</span>:
                print(<span class="hljs-string">"Error: You have to specify CV2 range as a list of two values. "</span>)
            <span class="hljs-keyword">if</span> cv3range!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> len(cv3range) != <span class="hljs-number">2</span>:
                print(<span class="hljs-string">"Error: You have to specify CV3 range as a list of two values. "</span>)
            
            <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
                self.cv1 = hills.get_cv1()
                self.s1 = hills.get_sigma1()

                self.cv1min = np.min(self.cv1) - <span class="hljs-number">1e-8</span>
                self.cv1max = np.max(self.cv1) + <span class="hljs-number">1e-8</span>

                self.cv1_name = hills.get_cv1_name()
                self.cv1per = hills.get_cv1per()
                
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> original:
                    <span class="hljs-keyword">if</span> ((np.max(self.s1)/np.min(self.s1))&gt;<span class="hljs-number">1.00000001</span>):
                        print(<span class="hljs-string">"""Error: Bias sum algorithm only works for hills files 
                        in which all hills have the same width. 
                        For this file, you need the slower but exact, algorithm, to do that, 
                        set the argument 'original' to True."""</span>)

            <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">2</span>:
                self.cv2 = hills.get_cv2()
                self.s2 = hills.get_sigma2()

                self.cv2min = np.min(self.cv2) - <span class="hljs-number">1e-8</span>
                self.cv2max = np.max(self.cv2) + <span class="hljs-number">1e-8</span>

                self.cv2_name = hills.get_cv2_name()
                self.cv2per = hills.get_cv2per()
                
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> original:
                    <span class="hljs-keyword">if</span> ((np.max(self.s2)/np.min(self.s2))&gt;<span class="hljs-number">1.00000001</span>):
                        print(<span class="hljs-string">"""Error: Bias sum algorithm only works for hills files 
                        in which all hills have the same width. 
                        For this file, you need the slower but exact, algorithm, to do that, 
                        set the argument 'original' to True."""</span>)

            <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
                self.cv3 = hills.get_cv3()
                self.s3 = hills.get_sigma3()

                self.cv3min = np.min(self.cv3) - <span class="hljs-number">1e-8</span>
                self.cv3max = np.max(self.cv3) + <span class="hljs-number">1e-8</span>

                self.cv3_name = hills.get_cv3_name()
                self.cv3per = hills.get_cv3per()
                
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> original:
                    <span class="hljs-keyword">if</span> ((np.max(self.s3)/np.min(self.s3))&gt;<span class="hljs-number">1.00000001</span>):
                        print(<span class="hljs-string">"""Error: Bias sum algorithm only works for hills files 
                        in which all hills have the same width of given CV. 
                        For this file, you need the slower but exact, algorithm, to do that, 
                        set the argument 'original' to True."""</span>)
            <span class="hljs-keyword">if</span> time_max != <span class="hljs-keyword">None</span>:     
                <span class="hljs-keyword">if</span> time_max &lt;= time_min:
                    print(<span class="hljs-string">"Error: End time is lower than start time"</span>)
                <span class="hljs-keyword">if</span> time_max &gt; len(self.cv1):
                    time_max = len(self.cv1)
                    print(<span class="hljs-string">f"Error: End time <span class="hljs-subst">{time_max}</span> is higher than number of lines in HILLS file <span class="hljs-subst">{len(self.cv1)}</span>, which will be used instead. "</span>)
            
            <span class="hljs-keyword">if</span> calculate_new_fes:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> original:
                    self.makefes(resolution, cv1range, cv2range, cv3range, time_min, time_max)
                <span class="hljs-keyword">else</span>:
                    self.makefes2(resolution, cv1range, cv2range, cv3range, time_min, time_max)
                        
        
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makefes</span><span class="hljs-params">(self, resolution, cv1range, cv2range, cv3range, time_min, time_max)</span>:</span>
        <span class="hljs-string">"""
        Function used internally for summing hills in Hills object with the fast Bias Sum Algorithm. 
        """</span>
        self.res = resolution
        <span class="hljs-comment">#if self.res % 2 == 0:</span>
        <span class="hljs-comment">#    self.res += 1</span>
                
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> cv1range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1range = self.cv1max-self.cv1min
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
            cv1_fes_range = cv1max-cv1min
                
            cv1bin = np.ceil((self.cv1-cv1min)*(self.res)/(cv1_fes_range))
            cv1bin = cv1bin.astype(int)
            s1res = (self.s1[<span class="hljs-number">0</span>]*self.res)/(cv1max - cv1min)
            self.cv1bin = cv1bin
            gauss_res = <span class="hljs-number">8</span>*s1res
            gauss_res = int(gauss_res)
            <span class="hljs-keyword">if</span> gauss_res%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
                gauss_res += <span class="hljs-number">1</span>
            
            gauss_center = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>
            gauss = np.zeros((gauss_res))
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gauss_res):
                <span class="hljs-comment">#dp2 = ((i+1)-gauss_center)**2/(2*s1res**2)</span>
                <span class="hljs-comment">#if dp2 &lt; 6.25:</span>
                <span class="hljs-comment">#    gauss[int(i)] = -np.exp(-dp2) * 1.00193418799744762399 - 0.00193418799744762399</span>
                gauss[int(i)] = -np.exp(-((i+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s1res**<span class="hljs-number">2</span>))
                
            fes = np.zeros((self.res))
            
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(cv1bin)):
                <span class="hljs-keyword">if</span> (line) % <span class="hljs-number">500</span> == <span class="hljs-number">0</span>:
                    print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{((line+<span class="hljs-number">1</span>)/len(cv1bin)):<span class="hljs-number">.1</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                
                <span class="hljs-comment">#fes_center = int((self.res-1)/2)</span>
                gauss_center_to_end = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)
                
                fes_to_edit_cv1 = [cv1bin[line]<span class="hljs-number">-1</span>-gauss_center_to_end,
                                   cv1bin[line]<span class="hljs-number">-1</span>+gauss_center_to_end]
                fes_crop_cv1 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv1[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv1[<span class="hljs-number">1</span>])]
                
                gauss_crop_cv1 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv1bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv1bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                
                fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    <span class="hljs-keyword">if</span> cv1bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv1_p = [self.res<span class="hljs-number">-1</span>+(cv1bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv1bin[line]]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv1bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv1bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [gauss_res-(gauss_center_to_end+cv1bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
            print(<span class="hljs-string">"\n"</span>)
            fes = fes-np.min(fes)
            self.fes = np.array(fes)
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> cv1range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1range = self.cv1max-self.cv1min
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
            cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2range = self.cv2max-self.cv2min
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = cv2range[<span class="hljs-number">0</span>]
                cv2max = cv2range[<span class="hljs-number">1</span>]
                self.cv2range = cv2range
            cv2_fes_range = cv2max-cv2min
            
            cv1bin = np.ceil((self.cv1-cv1min)*self.res/(cv1max-cv1min))
            cv2bin = np.ceil((self.cv2-cv2min)*self.res/(cv2max-cv2min))
                        
            cv1bin = cv1bin.astype(int)
            cv2bin = cv2bin.astype(int)
            
            s1res = (self.s1[<span class="hljs-number">0</span>]*self.res)/(cv1max - cv1min)
            s2res = (self.s2[<span class="hljs-number">0</span>]*self.res)/(cv2max - cv2min)
            
            gauss_res = max(<span class="hljs-number">8</span>*s1res, <span class="hljs-number">8</span>*s2res)
            gauss_res = int(gauss_res)
            <span class="hljs-keyword">if</span> gauss_res%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
                gauss_res += <span class="hljs-number">1</span>
            
            gauss_center = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>
            gauss = np.zeros((gauss_res,gauss_res))
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gauss_res):
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(gauss_res):
                    <span class="hljs-comment">#dp2 = ((i+1)-gauss_center)**2/(2*s1res**2) + ((j+1)-gauss_center)**2/(2*s2res**2)</span>
                    <span class="hljs-comment">#if dp2 &lt; 6.25:</span>
                    <span class="hljs-comment">#    gauss[int(i), int(j)] = -np.exp(-dp2) * 1.00193418799744762399 - 0.00193418799744762399</span>
                    gauss[int(i), int(j)] = -np.exp(-(((i+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s1res**<span class="hljs-number">2</span>) + ((j+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s2res**<span class="hljs-number">2</span>)))
            
            fes = np.zeros((self.res,self.res))
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(cv1bin)):
                <span class="hljs-keyword">if</span> (line) % <span class="hljs-number">500</span> == <span class="hljs-number">0</span>:
                    print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{((line+<span class="hljs-number">1</span>)/len(cv1bin)):<span class="hljs-number">.1</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                
                <span class="hljs-comment">#fes_center = int((self.res-1)/2)</span>
                gauss_center_to_end = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)
                <span class="hljs-comment">#print(f"\ng_res: {gauss_res}, gauss_center_to_end: {gauss_center_to_end}")</span>
                
                fes_to_edit_cv1 = [cv1bin[line]<span class="hljs-number">-1</span>-gauss_center_to_end,
                                   cv1bin[line]<span class="hljs-number">-1</span>+gauss_center_to_end]
                fes_to_edit_cv2 = [cv2bin[line]<span class="hljs-number">-1</span>-gauss_center_to_end,
                                   cv2bin[line]<span class="hljs-number">-1</span>+gauss_center_to_end]
                fes_crop_cv1 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv1[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv1[<span class="hljs-number">1</span>])]
                fes_crop_cv2 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv2[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv2[<span class="hljs-number">1</span>])]
                
                gauss_crop_cv1 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv1bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv1bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                gauss_crop_cv2 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv2bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv2bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                
                fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    <span class="hljs-keyword">if</span> cv1bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv1_p = [self.res<span class="hljs-number">-1</span>+(cv1bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv1bin[line]]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv1bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv1bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [gauss_res-(gauss_center_to_end+cv1bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">if</span> cv2bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv2_p = [self.res<span class="hljs-number">-1</span>+(cv2bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv2_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv2bin[line]]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv2bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv2_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv2bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv2_p = [gauss_res-(gauss_center_to_end+cv2bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">if</span> ((cv1bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv1bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv2bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv2bin[line] &gt; (self.res-gauss_center_to_end))):
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
            print(<span class="hljs-string">"\n"</span>)
            fes = fes-np.min(fes)
            self.fes = np.array(fes)
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> cv1range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1range = self.cv1max-self.cv1min
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
            cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2range = self.cv2max-self.cv2min
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = cv2range[<span class="hljs-number">0</span>]
                cv2max = cv2range[<span class="hljs-number">1</span>]
                self.cv2range = cv2range
            cv2_fes_range = cv2max-cv2min
            
            <span class="hljs-keyword">if</span> cv3range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                    cv3min = self.cv3per[<span class="hljs-number">0</span>]
                    cv3max = self.cv3per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv3min = self.cv3min
                    cv3max = self.cv3max
                    cv3range = self.cv3max-self.cv3min
                    cv3min -= cv3range*<span class="hljs-number">0.15</span>          
                    cv3max += cv3range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = cv3range[<span class="hljs-number">0</span>]
                cv3max = cv3range[<span class="hljs-number">1</span>]
                self.cv3range = cv3range
            cv3_fes_range = cv3max-cv3min
            
            cv1bin = np.ceil((self.cv1-cv1min)*self.res/(cv1max-cv1min))
            cv2bin = np.ceil((self.cv2-cv2min)*self.res/(cv2max-cv2min))
            cv3bin = np.ceil((self.cv3-cv3min)*self.res/(cv3max-cv3min))
                        
            cv1bin = cv1bin.astype(int)
            cv2bin = cv2bin.astype(int)
            cv3bin = cv3bin.astype(int)
            
            s1res = (self.s1[<span class="hljs-number">0</span>]*self.res)/(cv1max - cv1min)
            s2res = (self.s2[<span class="hljs-number">0</span>]*self.res)/(cv2max - cv2min)
            s3res = (self.s3[<span class="hljs-number">0</span>]*self.res)/(cv3max - cv3min)
            
            gauss_res = max(<span class="hljs-number">10</span>*s1res, <span class="hljs-number">10</span>*s2res, <span class="hljs-number">10</span>*s3res)
            gauss_res = int(gauss_res)
            <span class="hljs-keyword">if</span> gauss_res%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
                gauss_res += <span class="hljs-number">1</span>
            gauss_center = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>
            gauss = np.zeros((gauss_res,gauss_res,gauss_res))
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gauss_res):
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(gauss_res):
                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(gauss_res):
                        <span class="hljs-comment">#dp2 = ((i+1)-gauss_center)**2/(2*s1res**2) + ((j+1)-gauss_center)**2/(2*s2res**2) + ((k+1)-gauss_center)**2/(2*s3res**2)</span>
                        <span class="hljs-comment">#if dp2 &lt; 6.25:</span>
                        <span class="hljs-comment">#    gauss[int(i), int(j), int(k)] = -np.exp(-dp2) * 1.00193418799744762399 - 0.00193418799744762399</span>
                        gauss[int(i), int(j), int(k)] = -np.exp(-(((i+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s1res**<span class="hljs-number">2</span>) + 
                                                                  ((j+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s2res**<span class="hljs-number">2</span>) + 
                                                                  ((k+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s3res**<span class="hljs-number">2</span>)))
            
            fes = np.zeros((self.res, self.res, self.res))
            
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(cv1bin)):
                <span class="hljs-keyword">if</span> (line) % <span class="hljs-number">500</span> == <span class="hljs-number">0</span>:
                    print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{((line+<span class="hljs-number">1</span>)/len(cv1bin)):<span class="hljs-number">.1</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                
                <span class="hljs-comment">#fes_center = int((self.res-1)/2)</span>
                gauss_center_to_end = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)
                
                fes_to_edit_cv1 = [cv1bin[line]<span class="hljs-number">-1</span>-gauss_center_to_end,
                                   cv1bin[line]<span class="hljs-number">-1</span>+gauss_center_to_end]
                fes_to_edit_cv2 = [(cv2bin[line]<span class="hljs-number">-1</span>)-gauss_center_to_end,
                                   (cv2bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end]
                fes_to_edit_cv3 = [(cv3bin[line]<span class="hljs-number">-1</span>)-gauss_center_to_end,
                                   (cv3bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end]
                fes_crop_cv1 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv1[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv1[<span class="hljs-number">1</span>])]
                fes_crop_cv2 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv2[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv2[<span class="hljs-number">1</span>])]
                fes_crop_cv3 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv3[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv3[<span class="hljs-number">1</span>])]
                
                gauss_crop_cv1 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv1bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv1bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                gauss_crop_cv2 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv2bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv2bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                gauss_crop_cv3 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv3bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv3bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                
                fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                    fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                    fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                 gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                 gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    <span class="hljs-keyword">if</span> cv1bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv1_p = [self.res<span class="hljs-number">-1</span>+(cv1bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv1bin[line]]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv1bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv1bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [gauss_res-(gauss_center_to_end+cv1bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">if</span> cv2bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv2_p = [self.res<span class="hljs-number">-1</span>+(cv2bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv2_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv2bin[line]]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv2bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv2_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv2bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv2_p = [gauss_res-(gauss_center_to_end+cv2bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                    <span class="hljs-keyword">if</span> cv3bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv3_p = [self.res<span class="hljs-number">-1</span>+(cv3bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv3_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv3bin[line]]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv3bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv3_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv3bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv3_p = [gauss_res-(gauss_center_to_end+cv3bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">if</span> ((cv1bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv1bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv2bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv2bin[line] &gt; (self.res-gauss_center_to_end))):
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">2</span>]:
                    <span class="hljs-keyword">if</span> ((cv1bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv1bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv3bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv3bin[line] &gt; (self.res-gauss_center_to_end))):
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">2</span>]:
                    <span class="hljs-keyword">if</span> ((cv2bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv2bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv3bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv3bin[line] &gt; (self.res-gauss_center_to_end))):
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">2</span>]:
                    <span class="hljs-keyword">if</span> ((cv1bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv1bin[line] &gt; (self.res-gauss_center_to_end)))\
                            <span class="hljs-keyword">and</span> ((cv2bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv2bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv3bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv3bin[line] &gt; (self.res-gauss_center_to_end))) :
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
            
            print(<span class="hljs-string">"\n"</span>)
            fes = fes-np.min(fes)
            self.fes = np.array(fes)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Fes object doesn't have supported number of CVs."</span>)
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makefes2</span><span class="hljs-params">(self, resolution, cv1range, cv2range, cv3range, time_min, time_max)</span>:</span>
        <span class="hljs-string">"""
        Function internally used to sum Hills in the same way as Plumed sum_hills. 
        """</span>
        
        self.res = resolution
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> cv1range==<span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                    cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv1range = self.cv1max-self.cv1min
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
                    cv1_fes_range = cv1max - cv1min
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
                cv1_fes_range = cv1max-cv1min
            
            fes = np.zeros((self.res))
            
            progress = <span class="hljs-number">0</span>
            max_progress = self.res ** self.cvs
            
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(self.res):
                progress += <span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> (progress) % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:
                    print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{(progress/max_progress):<span class="hljs-number">.2</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                
                dist_cv1 = self.cv1-(cv1min+(x)*cv1_fes_range/(self.res))
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                    dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                
                dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1**<span class="hljs-number">2</span>)
                tmp = np.zeros(self.cv1.shape)
                tmp[dp2&lt;<span class="hljs-number">6.25</span>] = self.heights[dp2&lt;<span class="hljs-number">6.25</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">6.25</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                fes[x] = -tmp.sum()
                    
            fes = fes - np.min(fes)
            self.fes = np.array(fes)
            print(<span class="hljs-string">"\n"</span>)
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> cv1range==<span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                    cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv1range = self.cv1max-self.cv1min
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
                    cv1_fes_range = cv1max - cv1min
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
                cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                    cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv2range = self.cv2max-self.cv2min
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
                    cv2_fes_range = cv2max - cv2min
            <span class="hljs-keyword">else</span>:
                cv2min = cv2range[<span class="hljs-number">0</span>]
                cv2max = cv2range[<span class="hljs-number">1</span>]
                self.cv2range = cv2range
                cv2_fes_range = cv2max-cv2min
            
            fes = np.zeros((self.res, self.res))
            
            progress = <span class="hljs-number">0</span>
            max_progress = self.res ** self.cvs
            
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(self.res):
                dist_cv1 = self.cv1-(cv1min+(x)*cv1_fes_range/(self.res))
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                    dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                    
                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(self.res):
                    progress += <span class="hljs-number">1</span>
                    <span class="hljs-keyword">if</span> (progress) % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:
                        print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{(progress/max_progress):<span class="hljs-number">.2</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                    
                    dist_cv2 = self.cv2-(cv2min+(y)*cv2_fes_range/(self.res))
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                        dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                        dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                        
                    dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1**<span class="hljs-number">2</span>) + dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2**<span class="hljs-number">2</span>)
                    tmp = np.zeros(self.cv1.shape)
                    tmp[dp2&lt;<span class="hljs-number">6.25</span>] = self.heights[dp2&lt;<span class="hljs-number">6.25</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">6.25</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                    fes[x,y] = -tmp.sum()
                    
            fes = fes - np.min(fes)
            self.fes = np.array(fes)
            print(<span class="hljs-string">"\n"</span>)
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> cv1range==<span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                    cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv1range = self.cv1max-self.cv1min
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
                    cv1_fes_range = cv1max - cv1min
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
                cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                    cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv2range = self.cv2max-self.cv2min
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
                    cv2_fes_range = cv2max - cv2min
            <span class="hljs-keyword">else</span>:
                cv2min = cv2range[<span class="hljs-number">0</span>]
                cv2max = cv2range[<span class="hljs-number">1</span>]
                self.cv2range = cv2range
                cv2_fes_range = cv2max-cv2min
            
            <span class="hljs-keyword">if</span> cv3range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                    cv3min = self.cv3per[<span class="hljs-number">0</span>]
                    cv3max = self.cv3per[<span class="hljs-number">1</span>]
                    cv3_fes_range = np.abs(self.cv3per[<span class="hljs-number">1</span>]-self.cv3per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv3range = self.cv3max-self.cv3min
                    cv3min = self.cv3min
                    cv3max = self.cv3max
                    cv3min -= cv3range*<span class="hljs-number">0.15</span>          
                    cv3max += cv3range*<span class="hljs-number">0.15</span>
                    cv3_fes_range = cv3max - cv3min
            <span class="hljs-keyword">else</span>:
                cv3min = cv3range[<span class="hljs-number">0</span>]
                cv3max = cv3range[<span class="hljs-number">1</span>]
                self.cv3range = cv3range
                cv3_fes_range = cv3max-cv3min
            
            fes = np.zeros((self.res, self.res, self.res))
            
            progress = <span class="hljs-number">0</span>
            max_progress = self.res ** self.cvs
            
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(self.res):
                dist_cv1 = self.cv1-(cv1min+(x)*cv1_fes_range/(self.res))
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                    dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                    
                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(self.res):
                    dist_cv2 = self.cv2-(cv2min+(y)*cv2_fes_range/(self.res))
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                        dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                        dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                        
                    <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> range(self.res):
                        progress += <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> (progress) % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:
                            print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{(progress/max_progress):<span class="hljs-number">.2</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                        
                        dist_cv3 = self.cv3-(cv3min+(z)*cv3_fes_range/(self.res))
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                            dist_cv3[dist_cv3&lt;<span class="hljs-number">-0.5</span>*cv3_fes_range] += cv3_fes_range
                            dist_cv3[dist_cv3&gt;+<span class="hljs-number">0.5</span>*cv3_fes_range] -= cv3_fes_range
                        
                        dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1**<span class="hljs-number">2</span>) + dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2**<span class="hljs-number">2</span>) + dist_cv3**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s3**<span class="hljs-number">2</span>)
                        tmp = np.zeros(self.cv1.shape)
                        tmp[dp2&lt;<span class="hljs-number">6.25</span>] = self.heights[dp2&lt;<span class="hljs-number">6.25</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">6.25</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                        fes[x,y,z] = -tmp.sum()
                        
                        
                    
            fes = fes - np.min(fes)
            self.fes = np.array(fes)
            print(<span class="hljs-string">"\n"</span>)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">f"Error: unsupported number of CVs: <span class="hljs-subst">{self.cvs}</span>."</span>)
        
    
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span><span class="hljs-params">(self, png_name=None, contours=True, contours_spacing=<span class="hljs-number">0.0</span>, aspect = <span class="hljs-number">1.0</span>, cmap = <span class="hljs-string">"jet"</span>, 
                 energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
                 vmin = <span class="hljs-number">0</span>, vmax = None, opacity=<span class="hljs-number">0.2</span>, levels=None)</span>:</span>
        <span class="hljs-string">"""
        Function used to visualize FES, based on Matplotlib and PyVista. 
        
        ```python
        fes.plot(png_name="fes.png")
        ```
        
        Parameters:
        
        * png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.
        
        * contours (default=True) = whether contours should be shown on 2D FES
        
        * contours_spacing (default=0.0) = when a positive number is set, it will be used as spacing for contours on 2D FES. 
                Otherwise, if contours=True, there will be five equally spaced contour levels.
        
        * aspect (default = 1.0) = aspect ratio of the graph. Works with 1D and 2D FES. 
        
        * cmap (default = "jet") = Matplotlib colormap used to color 2D or 3D FES
        
        * energy_unit (default="kJ/mol") = String, used in description of colorbar
        
        * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graphs
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        * vmin (default=0) = real number, lower bound for the colormap on 2D FES
        
        * vmax = real number, upper bound for the colormap on 2D FES
        
        * opacity (default=0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
        
        * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
                        If not provided, default values from contours parameters will be used instead. 
        """</span>
        <span class="hljs-keyword">if</span> vmax == <span class="hljs-keyword">None</span>:
            vmax = np.max(self.fes)+<span class="hljs-number">0.01</span> <span class="hljs-comment"># if the addition is smaller than 0.01, the 3d plot stops working. </span>
            
        <span class="hljs-keyword">if</span> contours_spacing == <span class="hljs-number">0.0</span>:
            contours_spacing = (vmax-vmin)/<span class="hljs-number">5.0</span>
        
        cmap = cm.get_cmap(cmap)
        
        cmap.set_over(<span class="hljs-string">"white"</span>)
        cmap.set_under(<span class="hljs-string">"white"</span>)
        
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = self.cv3per[<span class="hljs-number">0</span>]
                cv3max = self.cv3per[<span class="hljs-number">1</span>] 
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
            X = np.linspace(cv1min, cv1max, self.res)
            plt.plot(X, self.fes)
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                plt.ylabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.ylabel(ylabel, size=label_size)
            
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">2</span>:
            fig = plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
            plt.imshow(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), cmap=cmap, interpolation=<span class="hljs-string">'nearest'</span>, 
                       extent=[cv1min, cv1max, cv2min, cv2max], 
                       aspect = (((cv1max-cv1min)/(cv2max-cv2min))/(aspect)),
                       vmin = vmin, vmax = vmax)
            cbar = plt.colorbar()
            cbar.set_label(energy_unit, size=label_size)
            <span class="hljs-keyword">if</span> contours:
                cont = plt.contour(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), 
                         levels = np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.01</span>), contours_spacing), 
                         extent=[cv1min, cv1max, cv2max, cv2min], 
                         colors = <span class="hljs-string">"k"</span>)
                plt.clabel(cont, levels = np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.01</span>), contours_spacing))
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                plt.ylabel(<span class="hljs-string">f'CV2 - <span class="hljs-subst">{self.cv2_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.ylabel(ylabel, size=label_size)
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                xlabel = <span class="hljs-string">"CV1 - "</span> + self.cv1_name
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                ylabel = <span class="hljs-string">"CV2 - "</span> + self.cv2_name
            <span class="hljs-keyword">if</span> zlabel == <span class="hljs-keyword">None</span>:
                zlabel = <span class="hljs-string">"CV3 - "</span> + self.cv3_name
            
            grid = pv.UniformGrid(
                dimensions=(self.res, self.res, self.res),
                spacing=((cv1max-cv1min)/self.res,(cv2max-cv2min)/self.res,(cv3max-cv3min)/self.res),
                origin=(cv1min, cv2min, cv3min)
            )
            grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
            <span class="hljs-keyword">if</span> levels == <span class="hljs-keyword">None</span>:
                contours = grid.contour(np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.01</span>), contours_spacing))
            <span class="hljs-keyword">else</span>:
                contours = grid.contour(levels)
            fescolors = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(contours.points.shape[<span class="hljs-number">0</span>]):
                fescolors.append(self.fes[int((contours.points[i,<span class="hljs-number">0</span>]-cv1min)*self.res/(cv1max-cv1min)),
                                          int((contours.points[i,<span class="hljs-number">1</span>]-cv2min)*self.res/(cv2max-cv2min)),
                                          int((contours.points[i,<span class="hljs-number">2</span>]-cv3min)*self.res/(cv3max-cv3min))])
            <span class="hljs-comment">#%% Visualization</span>
            pv.set_plot_theme(<span class="hljs-string">'document'</span>)
            p = pv.Plotter()
            p.add_mesh(contours, scalars=fescolors, opacity=opacity, cmap=cmap, show_scalar_bar=<span class="hljs-keyword">False</span>, interpolate_before_map=<span class="hljs-keyword">True</span>)
            p.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
            p.show()
            
        <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
            plt.savefig(png_name)
        
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_fes</span><span class="hljs-params">(self, fes)</span>:</span>
        self.fes = fes
        
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">surface_plot</span><span class="hljs-params">(self, cmap = <span class="hljs-string">"jet"</span>, 
                     energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, zlabel=None, 
                     label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">12</span>,<span class="hljs-number">7</span>], rstride=<span class="hljs-number">1</span>, cstride=<span class="hljs-number">1</span>, vmin = <span class="hljs-number">0</span>, vmax = None)</span>:</span>
        <span class="hljs-string">"""
        Function for visualization of 2D FES as 3D surface plot. For now, it is based on Matplotlib, but there are issues with interactivity. 
        
        It can be interacted with in jupyter notebook or jupyter lab in %matplotlib widget mode. Otherwise it is just static image of the 3D surface plot. 
        
        ```python
        %matplotlib widget
        fes.surface_plot()
        ```
        
        There are future plans to implement this function using the PyVista library.
        """</span>
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> self.cv1range==<span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                    cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv1range = self.cv1max-self.cv1min
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
                    cv1_fes_range = cv1max - cv1min
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1range[<span class="hljs-number">0</span>]
                cv1max = self.cv1range[<span class="hljs-number">1</span>]
                cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> self.cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                    cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv2range = self.cv2max-self.cv2min
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
                    cv2_fes_range = cv2max - cv2min
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2range[<span class="hljs-number">0</span>]
                cv2max = self.cv2range[<span class="hljs-number">1</span>]
                cv2_fes_range = cv2max-cv2min
            
            x = np.linspace(cv1min, cv1max, self.res)
            y = np.linspace(cv2min, cv2max, self.res)
            
            X, Y = np.meshgrid(x, y)
            Z = self.fes
            
            <span class="hljs-comment">#grid = pv.StructuredGrid(X, Y, Z)</span>
            <span class="hljs-comment">#grid.plot()</span>
            
            fig = plt.figure()
            ax = plt.axes(projection=<span class="hljs-string">"3d"</span>)
            ax.plot_surface(X,Y,Z, cmap=cmap, rstride=rstride, cstride=cstride)
            
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                ax.set_xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                ax.set_xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                ax.set_ylabel(<span class="hljs-string">f'CV2 - <span class="hljs-subst">{self.cv2_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                ax.set_ylabel(ylabel, size=label_size)
            <span class="hljs-keyword">if</span> zlabel == <span class="hljs-keyword">None</span>:
                ax.set_zlabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                ax.set_zlabel(zlabel, size=label_size)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">f"Surface plot only works for FES with exactly two CVs, and this FES has <span class="hljs-subst">{self.cvs}</span>"</span>)
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeCV</span><span class="hljs-params">(self, CV=None, energy_unit=<span class="hljs-string">"kJ/mol"</span>, temp=<span class="hljs-number">300.0</span>)</span>:</span>
        <span class="hljs-string">"""
        This function is used to remove a CV from an existing FES. The function first recalculates the FES to an array of probabilities. The probabilities 
        are summed along the CV to be removed, and resulting probability distribution with 1 less dimension is converted back to FES. 
        
        Parameters:
        
        * CV = integer, the CV to be removed
        
        * energy_unit (default="kJ/mol") = has to be either "kJ/mol" or "kcal/mol". Make sure to suply the correct energy unit, otherwise you will get wrong FES as a result. 
        
        * temp (default=300.0) = temperature of the simulation in Kelvins.
        """</span>
        CV = int(float(CV))
        print(<span class="hljs-string">f"Removing CV <span class="hljs-subst">{CV}</span>."</span>)
        <span class="hljs-keyword">if</span> CV &gt; self.cvs:
            print(<span class="hljs-string">"Error: The CV to remove is not available in this FES object."</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            print(<span class="hljs-string">"Error: You can not remove the only CV. "</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> energy_unit == <span class="hljs-string">"kJ/mol"</span>:
                probabilities = np.exp(<span class="hljs-number">-1000</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">1</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>]]
                    new_fes.cv1min = self.cv2min
                    new_fes.cv1max = self.cv2max
                    new_fes.cv1_name = self.cv2_name
                    new_fes.cv1per = self.cv2per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">1</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv1per = self.cv1per
                <span class="hljs-keyword">return</span> new_fes
            <span class="hljs-keyword">elif</span> energy_unit == <span class="hljs-string">"kcal/mol"</span>:
                probabilities = np.exp(<span class="hljs-number">-1000</span>*<span class="hljs-number">4.184</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">1</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>]]
                    new_fes.cv1min = self.cv2min
                    new_fes.cv1max = self.cv2max
                    new_fes.cv1_name = self.cv2_name
                    new_fes.cv1per = self.cv2per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">1</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv1per = self.cv1per
                <span class="hljs-keyword">return</span> new_fes
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">"Error: unknown energy unit"</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> energy_unit == <span class="hljs-string">"kJ/mol"</span>:
                probabilities = np.exp(<span class="hljs-number">-1000</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>], self.periodic[<span class="hljs-number">2</span>]]
                    new_fes.cv1min = self.cv2min
                    new_fes.cv1max = self.cv2max
                    new_fes.cv2min = self.cv3min
                    new_fes.cv2max = self.cv3max
                    new_fes.cv1_name = self.cv2_name
                    new_fes.cv2_name = self.cv3_name
                    new_fes.cv1per = self.cv2per
                    new_fes.cv2per = self.cv3per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">2</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv2min = self.cv3min
                    new_fes.cv2max = self.cv3max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv2_name = self.cv3_name
                    new_fes.cv1per = self.cv1per
                    new_fes.cv2per = self.cv3per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">3</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">2</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">1</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv2min = self.cv2min
                    new_fes.cv2max = self.cv2max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv2_name = self.cv2_name
                    new_fes.cv1per = self.cv1per
                    new_fes.cv2per = self.cv2per
                <span class="hljs-keyword">return</span> new_fes
            <span class="hljs-keyword">elif</span> energy_unit == <span class="hljs-string">"kcal/mol"</span>:
                probabilities = np.exp(<span class="hljs-number">-1000</span>*<span class="hljs-number">4.184</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>], self.periodic[<span class="hljs-number">2</span>]]
                    new_fes.cv1min = self.cv2min
                    new_fes.cv1max = self.cv2max
                    new_fes.cv2min = self.cv3min
                    new_fes.cv2max = self.cv3max
                    new_fes.cv1_name = self.cv2_name
                    new_fes.cv2_name = self.cv3_name
                    new_fes.cv1per = self.cv2per
                    new_fes.cv2per = self.cv3per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">2</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv2min = self.cv3min
                    new_fes.cv2max = self.cv3max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv2_name = self.cv3_name
                    new_fes.cv1per = self.cv1per
                    new_fes.cv2per = self.cv3per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">3</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">2</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">1</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv2min = self.cv2min
                    new_fes.cv2max = self.cv2max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv2_name = self.cv2_name
                    new_fes.cv1per = self.cv1per
                    new_fes.cv2per = self.cv2per
                <span class="hljs-keyword">return</span> new_fes
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">"Error: unknown energy unit"</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_gif</span><span class="hljs-params">(self, gif_name=None, cmap = <span class="hljs-string">"jet"</span>, 
                 xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
                  opacity=<span class="hljs-number">0.2</span>, levels=None, frames=<span class="hljs-number">64</span>)</span>:</span>
        <span class="hljs-string">"""
        Function that generates animation of 3D FES showing different isosurfaces.
        
        ```python
        fes.make_gif(gif_name="FES.gif")
        ```
        
        Parameters:
        
        * gif_name (default="FES.gif") = String. Name of the gif of FES that will be saved in the current working directory.
        
        * cmap (default = "jet") = Matplotlib colormap used to color the 3D FES
        
        * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graph
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        * opacity (default = 0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
        
        * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
                If not provided, default values from contours parameters will be used instead. 
        
        * frames (default = 64) = Number of frames the animation will be made of. 
        """</span>
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                    cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                <span class="hljs-keyword">else</span>:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>] 
            <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                    cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                <span class="hljs-keyword">else</span>:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>] 
            <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                    cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                    cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                <span class="hljs-keyword">else</span>:
                    cv3min = self.cv3per[<span class="hljs-number">0</span>]
                    cv3max = self.cv3per[<span class="hljs-number">1</span>] 
            
            values = np.linspace(np.min(self.fes)+<span class="hljs-number">0.01</span>, np.max(self.fes), num=frames)
            grid = pv.UniformGrid(
                dimensions=(self.res, self.res, self.res),
                spacing=((cv1max-cv1min)/self.res,(cv2max-cv2min)/self.res,(cv3max-cv3min)/self.res),
                origin=(cv1min, cv2min, cv3min),
            )
            grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
            surface = grid.contour(values[:<span class="hljs-number">1</span>])
            surfaces = [grid.contour([v]) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]
            surface = surfaces[<span class="hljs-number">0</span>].copy()
            
            pv.set_plot_theme(<span class="hljs-string">'document'</span>)
            plotter = pv.Plotter(off_screen=<span class="hljs-keyword">True</span>)
            <span class="hljs-comment"># Open a movie file</span>
            plotter.open_gif(gif_name)

            <span class="hljs-comment"># Add initial mesh</span>
            plotter.add_mesh(
                surface,
                opacity=<span class="hljs-number">0.3</span>,
                clim=grid.get_data_range(),
                show_scalar_bar=<span class="hljs-keyword">False</span>,
                cmap=<span class="hljs-string">"jet"</span>
            )
            plotter.add_mesh(grid.outline_corners(), color=<span class="hljs-string">"k"</span>)
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> ylabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> zlabel == <span class="hljs-keyword">None</span>:
                plotter.show_grid(xlabel=<span class="hljs-string">f"CV1 - <span class="hljs-subst">{self.cv1_name}</span>"</span>, ylabel=<span class="hljs-string">f"CV2 - <span class="hljs-subst">{self.cv2_name}</span>"</span>, zlabel=<span class="hljs-string">f"CV3 - <span class="hljs-subst">{self.cv3_name}</span>"</span>)
            <span class="hljs-keyword">else</span>:
                plotter.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
            plotter.set_background(<span class="hljs-string">'white'</span>)
            plotter.show(auto_close=<span class="hljs-keyword">False</span>)

            <span class="hljs-comment"># Run through each frame</span>
            <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces:
                surface.copy_from(surf)
                plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>
            <span class="hljs-comment"># Run through backwards</span>
            <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces[::<span class="hljs-number">-1</span>]:
                surface.copy_from(surf)
                plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>

            <span class="hljs-comment"># Be sure to close the plotter when finished</span>
            plotter.close()
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Error: gif_plot is only available for FES with 3 CVs."</span>)     

            
            
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Minima</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-string">"""
    Object of Minima class is created to find local free energy minima on FES. 
    The FES is first divided to some number of bins, 
    (the number of bins can be set with option nbins, default is 8)
    and the absolute minima is found for each bin. Then the algorithm checks 
    if this point is really a local minimum by comparing to the surrounding points of FES.
    
    The list of minima is stored as pandas dataframe. 
    
    Command:
    ```python
    minima = metadynminer.Minima(fes=f, nbins=8)
    ```
    
    List of minima can be later called like this:
    
    ```python
    print(minima.minima)
    ```
    
    Parameters:
    
    * fes = Fes object to find the minima on
    
    * nbins (default = 8) = number of bins to divide the FES
    """</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, fes, nbins = <span class="hljs-number">8</span>)</span>:</span>
        self.fes = fes.fes
        self.periodic = fes.periodic
        self.cvs = fes.cvs
        self.res = fes.res

        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            self.cv1_name = fes.cv1_name
            self.cv1min = fes.cv1min
            self.cv1max = fes.cv1max
            self.cv1per = fes.cv1per
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">2</span>:
            self.cv2min = fes.cv2min
            self.cv2max = fes.cv2max
            self.cv2_name = fes.cv2_name
            self.cv2per = fes.cv2per
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            self.cv3min = fes.cv3min
            self.cv3max = fes.cv3max
            self.cv3_name = fes.cv3_name
            self.cv3per = fes.cv3per
        
        self.findminima(nbins=nbins)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findminima</span><span class="hljs-params">(self, nbins=<span class="hljs-number">8</span>)</span>:</span>
        <span class="hljs-string">"""
        Internal method for finding local minima on FES.
        """</span>
        <span class="hljs-keyword">if</span> int(nbins) != nbins:
            nbins = int(nbins)
            print(<span class="hljs-string">f"Number of bins must be an integer, it will be set to <span class="hljs-subst">{nbins}</span>."</span>)
        <span class="hljs-keyword">if</span> self.res%nbins != <span class="hljs-number">0</span>:
            print(<span class="hljs-string">"Error: Resolution of FES must be divisible by number of bins."</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">if</span> nbins &gt; self.res/<span class="hljs-number">2</span>:
            print(<span class="hljs-string">"Error: Number of bins is too high."</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        bin_size = int(self.res/nbins)

        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1min
                cv1max = self.cv1max 
        <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2min
                cv2max = self.cv2max 
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = self.cv3min
                cv3max = self.cv3max

        self.minima = []
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">for</span> bin1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                fes_slice = self.fes[bin1*bin_size:(bin1+<span class="hljs-number">1</span>)*bin_size]
                bin_min = np.min(fes_slice)
                argmin = np.argmin(fes_slice)
                <span class="hljs-comment"># indexes of global minimum of a bin</span>
                bin_min_arg_cv1 = int(argmin%bin_size)
                <span class="hljs-comment"># indexes of that minima in the original fes (indexes +1)</span>
                min_cv1_b = int(bin_min_arg_cv1+bin1*bin_size)
                <span class="hljs-keyword">if</span> (bin_min_arg_cv1 &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg_cv1&lt;(bin_size<span class="hljs-number">-1</span>)):
                    min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                    <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                        self.minima = np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])
                    <span class="hljs-keyword">else</span>:
                        self.minima = np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])))
                <span class="hljs-keyword">else</span>:
                    around = []
                    min_cv1_b_low = min_cv1_b - <span class="hljs-number">1</span>
                    <span class="hljs-keyword">if</span> min_cv1_b_low == <span class="hljs-number">-1</span>:
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                            min_cv1_b_low = self.res - <span class="hljs-number">1</span>
                        <span class="hljs-keyword">else</span>:
                            min_cv1_b_low = float(<span class="hljs-string">"nan"</span>)

                    min_cv1_b_high = min_cv1_b + <span class="hljs-number">1</span>
                    <span class="hljs-keyword">if</span> min_cv1_b_high == self.res:
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                            min_cv1_b_high = <span class="hljs-number">0</span>
                        <span class="hljs-keyword">else</span>:
                            min_cv1_b_high = float(<span class="hljs-string">"nan"</span>)

                    <span class="hljs-comment">#1_b_low</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                        around.append(self.fes[min_cv1_b_low])
                    <span class="hljs-comment">#1_b_high</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                        around.append(self.fes[min_cv1_b_high])
                    
                    <span class="hljs-keyword">if</span> bin_min &lt; np.min(around):
                        min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                        <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                            self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])
                        <span class="hljs-keyword">else</span>:
                            self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])))
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">for</span> bin1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                <span class="hljs-keyword">for</span> bin2 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                    fes_slice = self.fes[bin1*bin_size:(bin1+<span class="hljs-number">1</span>)*bin_size,
                                         bin2*bin_size:(bin2+<span class="hljs-number">1</span>)*bin_size]
                    bin_min = np.min(fes_slice)
                    argmin = np.argmin(fes_slice)
                    <span class="hljs-comment"># indexes of global minimum of a bin</span>
                    bin_min_arg = np.unravel_index(np.argmin(fes_slice), fes_slice.shape)
                    <span class="hljs-comment"># indexes of that minima in the original fes (indexes +1)</span>
                    min_cv1_b = int(bin_min_arg[<span class="hljs-number">0</span>]+bin1*bin_size)
                    min_cv2_b = int(bin_min_arg[<span class="hljs-number">1</span>]+bin2*bin_size)
                    <span class="hljs-keyword">if</span> (bin_min_arg[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">0</span>]&lt;(bin_size<span class="hljs-number">-1</span>)) \
                                    <span class="hljs-keyword">and</span> (bin_min_arg[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">1</span>]&lt;(bin_size<span class="hljs-number">-1</span>)):
                        min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                        min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                        <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                            self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                  int(min_cv2_b), round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])
                        <span class="hljs-keyword">else</span>:
                            self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), \
                                                                          int(min_cv2_b), round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])))
                    <span class="hljs-keyword">else</span>:
                        around = []
                        min_cv1_b_low = min_cv1_b - <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv1_b_low == <span class="hljs-number">-1</span>:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv1_b_low = self.res - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv1_b_low = float(<span class="hljs-string">"nan"</span>)

                        min_cv1_b_high = min_cv1_b + <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv1_b_high == self.res:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv1_b_high = <span class="hljs-number">0</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv1_b_high = float(<span class="hljs-string">"nan"</span>)

                        min_cv2_b_low = min_cv2_b - <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv2_b_low == <span class="hljs-number">-1</span>:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv2_b_low = self.res - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv2_b_low = float(<span class="hljs-string">"nan"</span>)

                        min_cv2_b_high = min_cv2_b + <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv2_b_high == self.res:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv2_b_high = <span class="hljs-number">0</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv2_b_high = float(<span class="hljs-string">"nan"</span>)
                        <span class="hljs-comment">#1_b_low</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                around.append(self.fes[min_cv1_b_low, min_cv2_b_low])
                            around.append(self.fes[min_cv1_b_low,min_cv2_b])
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                around.append(self.fes[min_cv1_b_low, min_cv2_b_high])
                        <span class="hljs-comment">#1_b</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                            around.append(self.fes[min_cv1_b, min_cv2_b_low])
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                            around.append(self.fes[min_cv1_b, min_cv2_b_high])
                        <span class="hljs-comment">#1_b_high</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                around.append(self.fes[min_cv1_b_high, min_cv2_b_low])
                            around.append(self.fes[min_cv1_b_high, min_cv2_b])
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                around.append(self.fes[min_cv1_b_high, min_cv2_b_high])
                        <span class="hljs-keyword">if</span> bin_min &lt; np.min(around):
                            min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                            min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                            <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                                self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), int(min_cv2_b), \
                                                      round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])
                            <span class="hljs-keyword">else</span>:
                                self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), \
                                                                              int(min_cv2_b), round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])))
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">for</span> bin1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                <span class="hljs-keyword">for</span> bin2 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                    <span class="hljs-keyword">for</span> bin3 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, nbins):
                        fes_slice = self.fes[bin1*bin_size:(bin1+<span class="hljs-number">1</span>)*bin_size,
                                             bin2*bin_size:(bin2+<span class="hljs-number">1</span>)*bin_size, 
                                             bin3*bin_size:(bin3+<span class="hljs-number">1</span>)*bin_size]
                        bin_min = np.min(fes_slice)
                        argmin = np.argmin(fes_slice)
                        <span class="hljs-comment"># indexes of global minimum of a bin</span>
                        bin_min_arg = np.unravel_index(np.argmin(fes_slice), fes_slice.shape)
                        <span class="hljs-comment"># indexes of that minima in the original fes (indexes +1)</span>
                        min_cv1_b = int(bin_min_arg[<span class="hljs-number">0</span>]+bin1*bin_size)
                        min_cv2_b = int(bin_min_arg[<span class="hljs-number">1</span>]+bin2*bin_size)
                        min_cv3_b = int(bin_min_arg[<span class="hljs-number">2</span>]+bin3*bin_size)
                        <span class="hljs-keyword">if</span> (bin_min_arg[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">0</span>]&lt;(bin_size<span class="hljs-number">-1</span>)) \
                                        <span class="hljs-keyword">and</span> (bin_min_arg[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">1</span>]&lt;(bin_size<span class="hljs-number">-1</span>))\
                                        <span class="hljs-keyword">and</span> (bin_min_arg[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">2</span>]&lt;(bin_size<span class="hljs-number">-1</span>)):
                            min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                            min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                            min_cv3 = (((min_cv3_b+<span class="hljs-number">0.5</span>)/self.res)*(cv3max-cv3min))+cv3min
                            <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                                self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])
                            <span class="hljs-keyword">else</span>:
                                self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])))
                        <span class="hljs-keyword">else</span>:
                            around = []
                            min_cv1_b_low = min_cv1_b - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv1_b_low == <span class="hljs-number">-1</span>:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv1_b_low = self.res - <span class="hljs-number">1</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv1_b_low = float(<span class="hljs-string">"nan"</span>)

                            min_cv1_b_high = min_cv1_b + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv1_b_high == self.res:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv1_b_high = <span class="hljs-number">0</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv1_b_high = float(<span class="hljs-string">"nan"</span>)

                            min_cv2_b_low = min_cv2_b - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv2_b_low == <span class="hljs-number">-1</span>:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv2_b_low = self.res - <span class="hljs-number">1</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv2_b_low = float(<span class="hljs-string">"nan"</span>)

                            min_cv2_b_high = min_cv2_b + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv2_b_high == self.res:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv2_b_high = <span class="hljs-number">0</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv2_b_high = float(<span class="hljs-string">"nan"</span>)
                                                       
                            min_cv3_b_low = min_cv3_b - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv3_b_low == <span class="hljs-number">-1</span>:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                                    min_cv3_b_low = self.res - <span class="hljs-number">1</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv3_b_low = float(<span class="hljs-string">"nan"</span>)

                            min_cv3_b_high = min_cv3_b + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv3_b_high == self.res:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                                    min_cv3_b_high = <span class="hljs-number">0</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv3_b_high = float(<span class="hljs-string">"nan"</span>)

<span class="hljs-comment">#cv3_b</span>
                            <span class="hljs-comment">#1_b_low</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b_low,min_cv3_b])
                                around.append(self.fes[min_cv1_b_low,min_cv2_b,min_cv3_b])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b_high,min_cv3_b])
                            <span class="hljs-comment">#1_b</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                around.append(self.fes[min_cv1_b,min_cv2_b_low,min_cv3_b])
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                around.append(self.fes[min_cv1_b,min_cv2_b_high,min_cv3_b])
                            <span class="hljs-comment">#1_b_high</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b_low,min_cv3_b])
                                around.append(self.fes[min_cv1_b_high,min_cv2_b,min_cv3_b])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b_high,min_cv3_b])
                           
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv3_b_low)):
                            <span class="hljs-comment">#1_b_low</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_low,min_cv3_b_low])
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b,min_cv3_b_low])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_high,min_cv3_b_low])
                                <span class="hljs-comment">#1_b</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_low,min_cv3_b_low])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_high,min_cv3_b_low])
                                <span class="hljs-comment">#1_b_high</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_low,min_cv3_b_low])
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b,min_cv3_b_low])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_high,min_cv3_b_low])
                            
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                <span class="hljs-comment">#1_b_low</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_low,min_cv3_b_high])
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b,min_cv3_b_high])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_high,min_cv3_b_high])
                                <span class="hljs-comment">#1_b</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_low,min_cv3_b_high])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_high,min_cv3_b_high])
                                <span class="hljs-comment">#1_b_high</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_low,min_cv3_b_high])
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b,min_cv3_b_high])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_high,min_cv3_b_high])
                            
                            <span class="hljs-keyword">if</span> bin_min &lt; np.min(around):
                                min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                                min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                                min_cv3 = (((min_cv3_b+<span class="hljs-number">0.5</span>)/self.res)*(cv3max-cv3min))+cv3min
                                <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                                    self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])
                                <span class="hljs-keyword">else</span>:
                                    self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])))
        
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Fes object has unsupported number of CVs."</span>)
        
        <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
            self.minima = self.minima[self.minima[:, <span class="hljs-number">0</span>].argsort()]

        letters = list(map(chr, range(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>)))
        <span class="hljs-keyword">for</span> letter1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>):
            <span class="hljs-keyword">for</span> letter2 <span class="hljs-keyword">in</span> range(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>):
                letters.append(<span class="hljs-string">f"<span class="hljs-subst">{chr(letter1)}</span><span class="hljs-subst">{chr(letter2)}</span>"</span>)
        <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> self.minima.shape[<span class="hljs-number">1</span>] &lt; len(letters):
                self.minima = np.column_stack((letters[<span class="hljs-number">0</span>:self.minima.shape[<span class="hljs-number">0</span>]],self.minima))
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">"Error: Too many minima to assign letters."</span>)
        <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
            self.minima = np.append(<span class="hljs-string">"A"</span>, self.minima)
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
                self.minima = pd.DataFrame(np.array(self.minima), columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV1 - "</span>+self.cv1_name])
            <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
                self.minima = pd.DataFrame([self.minima], columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV1 - "</span>+self.cv1_name])
                
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
                self.minima = pd.DataFrame(np.array(self.minima), columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name])
            <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
                self.minima = pd.DataFrame([self.minima], columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name])
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
                self.minima = pd.DataFrame(np.array(self.minima), columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, <span class="hljs-string">"CV3bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name,  <span class="hljs-string">"CV3 - "</span>+self.cv3_name])
            <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
                self.minima = pd.DataFrame([self.minima], columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, <span class="hljs-string">"CV3bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name,  <span class="hljs-string">"CV3 - "</span>+self.cv3_name])
        

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span><span class="hljs-params">(self, png_name=None, contours=True, contours_spacing=<span class="hljs-number">0.0</span>, aspect = <span class="hljs-number">1.0</span>, cmap = <span class="hljs-string">"jet"</span>, 
                 energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
                 color=None, vmin = <span class="hljs-number">0</span>, vmax = None, opacity=<span class="hljs-number">0.2</span>, levels=None, show_points=True, point_size=<span class="hljs-number">4.0</span>)</span>:</span>
        <span class="hljs-string">"""
        The same function as for visualizing Fes objects, but this time 
        with the positions of local minima shown as letters on the graph.
        
        ```python
        minima.plot(png_name="minima.png")
        ```
        
        Parameters:
        
        * png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.
        
        * contours (default=True) = whether contours should be shown on 2D FES
        
        * contours_spacing (default=0.0) = when a positive number is set, it will be used as spacing for contours on 2D FES. 
                Otherwise, if contours=True, there will be five equally spaced contour levels.
        
        * aspect (default = 1.0) = aspect ratio of the graph. Works with 1D and 2D FES. 
        
        * cmap (default = "jet") = Matplotlib colormap used to color 2D or 3D FES
        
        * energy_unit (default="kJ/mol") = String, used in description of colorbar
        
        * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graphs
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        * color = string = name of color in matplotlib, if set, the color will be used for the letters. 
                If not set, the color should be automatically either black or white, 
                depending on what will be better visible on given place on FES with given colormap (for 2D FES).
        
        * vmin (default=0) = real number, lower bound for the colormap on 2D FES
        
        * vmax = real number, upper bound for the colormap on 2D FES
        
        * opacity (default=0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
        
        * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
                If not provided, default values from contours parameters will be used instead. 
        
        * show_points (default=True) = boolean, tells if points should be visualized too, instead of just the letters. Only on 3D FES. 
        
        * point_size (default=4.0) = float, sets the size of points if show_points=True
        """</span>
        
        <span class="hljs-keyword">if</span> vmax == <span class="hljs-keyword">None</span>:
            vmax = np.max(self.fes)+<span class="hljs-number">0.01</span> <span class="hljs-comment"># if the addition is smaller than 0.01, the 3d plot stops working. </span>
            
        <span class="hljs-keyword">if</span> contours_spacing == <span class="hljs-number">0.0</span>:
            contours_spacing = (vmax-vmin)/<span class="hljs-number">5.0</span>
        
        cmap = cm.get_cmap(cmap)
        
        cmap.set_over(<span class="hljs-string">"white"</span>)
        cmap.set_under(<span class="hljs-string">"white"</span>)
        
        color_set = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">if</span> color == <span class="hljs-keyword">None</span>:
            color_set = <span class="hljs-keyword">False</span>
        
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = self.cv3per[<span class="hljs-number">0</span>]
                cv3max = self.cv3per[<span class="hljs-number">1</span>] 
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
            X = np.linspace(cv1min, cv1max, self.res)
            plt.plot(X, self.fes)
            
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> color_set:
                color = <span class="hljs-string">"black"</span>
            
            ferange = np.max(self.fes) - np.min(self.fes)
            
            
            <span class="hljs-keyword">if</span> self.minima.shape[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:
                plt.text(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]), float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])+ferange*<span class="hljs-number">0.05</span>, self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                             fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                             verticalalignment=<span class="hljs-string">'bottom'</span>, c=color)
            <span class="hljs-keyword">elif</span> self.minima.shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>:
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.minima.iloc[:,<span class="hljs-number">0</span>])):
                    plt.text(float(self.minima.iloc[m,<span class="hljs-number">3</span>]), float(self.minima.iloc[m,<span class="hljs-number">1</span>])+ferange*<span class="hljs-number">0.05</span>, self.minima.iloc[m,<span class="hljs-number">0</span>],
                             fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                             verticalalignment=<span class="hljs-string">'bottom'</span>, c=color)
            
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                plt.ylabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.ylabel(ylabel, size=label_size)
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            fig = plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
            plt.imshow(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), cmap=cmap, interpolation=<span class="hljs-string">'nearest'</span>, 
                       extent=[cv1min, cv1max, cv2min, cv2max], 
                       aspect = (((cv1max-cv1min)/(cv2max-cv2min))/(aspect)),
                       vmin = vmin, vmax = vmax)
            cbar = plt.colorbar()
            cbar.set_label(energy_unit, size=label_size)

            <span class="hljs-keyword">if</span> self.minima.shape[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:
                background = cmap((float(self.minima.iloc[<span class="hljs-number">1</span>])-vmin)/(vmax-vmin))
                luma = background[<span class="hljs-number">0</span>]*<span class="hljs-number">0.2126</span>+background[<span class="hljs-number">1</span>]*<span class="hljs-number">0.7152</span>+background[<span class="hljs-number">3</span>]*<span class="hljs-number">0.0722</span>
                <span class="hljs-keyword">if</span> luma &gt; <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                    color = <span class="hljs-string">"black"</span>
                <span class="hljs-keyword">elif</span> luma &lt;= <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                    color=<span class="hljs-string">"white"</span>
                plt.text(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]), float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]), self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                             fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                             verticalalignment=<span class="hljs-string">'center'</span>, c=color)
            <span class="hljs-keyword">elif</span> self.minima.shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>:
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.minima.iloc[:,<span class="hljs-number">0</span>])):
                    background = cmap((float(self.minima.iloc[m,<span class="hljs-number">1</span>])-vmin)/(vmax-vmin))
                    luma = background[<span class="hljs-number">0</span>]*<span class="hljs-number">0.2126</span>+background[<span class="hljs-number">1</span>]*<span class="hljs-number">0.7152</span>+background[<span class="hljs-number">3</span>]*<span class="hljs-number">0.0722</span>
                    <span class="hljs-keyword">if</span> luma &gt; <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                        color = <span class="hljs-string">"black"</span>
                    <span class="hljs-keyword">elif</span> luma &lt;= <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                        color=<span class="hljs-string">"white"</span>
                    plt.text(float(self.minima.iloc[m,<span class="hljs-number">4</span>]), float(self.minima.iloc[m,<span class="hljs-number">5</span>]), self.minima.iloc[m,<span class="hljs-number">0</span>],
                             fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                             verticalalignment=<span class="hljs-string">'center'</span>, c=color)

            <span class="hljs-keyword">if</span> contours:
                cont = plt.contour(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), 
                         levels = np.arange(<span class="hljs-number">0</span>, (vmax + <span class="hljs-number">0.01</span>), contours_spacing), 
                         extent=[cv1min, cv1max, cv2max, cv2min], 
                         colors = <span class="hljs-string">"k"</span>)
                plt.clabel(cont, levels = np.arange(<span class="hljs-number">0</span>, (vmax + <span class="hljs-number">0.01</span>), contours_spacing))
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                plt.ylabel(<span class="hljs-string">f'CV2 - <span class="hljs-subst">{self.cv2_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.ylabel(ylabel, size=label_size)
        
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                xlabel = <span class="hljs-string">"CV1 - "</span> + self.cv1_name
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                ylabel = <span class="hljs-string">"CV2 - "</span> + self.cv2_name
            <span class="hljs-keyword">if</span> zlabel == <span class="hljs-keyword">None</span>:
                zlabel = <span class="hljs-string">"CV3 - "</span> + self.cv3_name
            
            min_ar = self.minima.iloc[:,<span class="hljs-number">5</span>:<span class="hljs-number">8</span>].values
            min_ar = min_ar.astype(np.float32)
            min_pv = pv.PolyData(min_ar)
            grid = pv.UniformGrid(
                dimensions=(self.res, self.res, self.res),
                spacing=((cv1max-cv1min)/self.res,(cv2max-cv2min)/self.res,(cv3max-cv3min)/self.res),
                origin=(cv1min, cv2min, cv3min)
            )
            grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
            <span class="hljs-keyword">if</span> levels == <span class="hljs-keyword">None</span>:
                contours = grid.contour(np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.1</span>), contours_spacing))
            <span class="hljs-keyword">else</span>:
                contours = grid.contour(levels)
            fescolors = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(contours.points.shape[<span class="hljs-number">0</span>]):
                fescolors.append(self.fes[int((contours.points[i,<span class="hljs-number">0</span>]-cv1min)*self.res/(cv1max-cv1min)),
                                          int((contours.points[i,<span class="hljs-number">1</span>]-cv2min)*self.res/(cv2max-cv2min)),
                                          int((contours.points[i,<span class="hljs-number">2</span>]-cv3min)*self.res/(cv3max-cv3min))])
            <span class="hljs-comment">#%% Visualization</span>
            pv.set_plot_theme(<span class="hljs-string">'document'</span>)
            p = pv.Plotter()
            p.add_mesh(contours, scalars=fescolors, opacity=opacity, cmap=cmap, show_scalar_bar=<span class="hljs-keyword">False</span>, interpolate_before_map=<span class="hljs-keyword">True</span>)
            p.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
            p.add_point_labels(min_pv, self.minima.iloc[:,<span class="hljs-number">0</span>], 
                   show_points=show_points, always_visible = <span class="hljs-keyword">True</span>, 
                   point_color=<span class="hljs-string">"black"</span>, point_size=point_size, 
                   font_size=label_size, shape=<span class="hljs-keyword">None</span>)
            p.show()
            
        <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
            plt.savefig(png_name)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_gif</span><span class="hljs-params">(self, gif_name=None, cmap = <span class="hljs-string">"jet"</span>, 
                 xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
                  opacity=<span class="hljs-number">0.2</span>, levels=None, show_points=True, point_size=<span class="hljs-number">4.0</span>, frames=<span class="hljs-number">64</span>)</span>:</span>
        <span class="hljs-string">"""
        Function that generates animation of 3D FES showing different isosurfaces.
        
        ```python
        fes.make_gif(gif_name="FES.gif")
        ```
        
        Parameters:
        
        * gif_name (default="minima.gif") = String. Name of the gif that will be saved in the working directory.
        
        * cmap (default = "jet") = Matplotlib colormap used to color the 3D FES
        
        * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graph
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        * opacity (default = 0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
        
        * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
                If not provided, default values from contours parameters will be used instead. 
        
        * frames (default = 64) = Number of frames the animation will be made of. 
        """</span>
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            values = np.linspace(np.min(self.fes)+<span class="hljs-number">1</span>, np.max(self.fes), num=frames)
            grid = pv.UniformGrid(
                dimensions=(self.res, self.res, self.res),
                spacing=((self.cv1max-self.cv1min)/self.res,(self.cv2max-self.cv2min)/self.res,(self.cv3max-self.cv3min)/self.res),
                origin=(self.cv1min, self.cv2min, self.cv3min),
            )
            grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
            surface = grid.contour(values[:<span class="hljs-number">1</span>])
            surfaces = [grid.contour([v]) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]
            surface = surfaces[<span class="hljs-number">0</span>].copy()
            
            pv.set_plot_theme(<span class="hljs-string">'document'</span>)
            plotter = pv.Plotter(off_screen=<span class="hljs-keyword">True</span>)
            <span class="hljs-comment"># Open a movie file</span>
            plotter.open_gif(gif_name)

            <span class="hljs-comment"># Add initial mesh</span>
            plotter.add_mesh(
                surface,
                opacity=<span class="hljs-number">0.3</span>,
                clim=grid.get_data_range(),
                show_scalar_bar=<span class="hljs-keyword">False</span>,
                cmap=<span class="hljs-string">"jet"</span>
            )
            plotter.add_mesh(grid.outline_corners(), color=<span class="hljs-string">"k"</span>)
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> ylabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> zlabel == <span class="hljs-keyword">None</span>:
                plotter.show_grid(xlabel=<span class="hljs-string">f"CV1 - <span class="hljs-subst">{self.cv1_name}</span>"</span>, ylabel=<span class="hljs-string">f"CV2 - <span class="hljs-subst">{self.cv2_name}</span>"</span>, zlabel=<span class="hljs-string">f"CV3 - <span class="hljs-subst">{self.cv3_name}</span>"</span>)
            <span class="hljs-keyword">else</span>:
                plotter.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
            <span class="hljs-keyword">if</span> show_points:
                min_ar = self.minima.iloc[:,<span class="hljs-number">5</span>:<span class="hljs-number">8</span>].values
                min_ar = min_ar.astype(np.float32)
                min_pv = pv.PolyData(min_ar)
                plotter.add_point_labels(min_pv, self.minima.iloc[:,<span class="hljs-number">0</span>], 
                               show_points=<span class="hljs-keyword">True</span>, always_visible = <span class="hljs-keyword">True</span>, 
                               pickable = <span class="hljs-keyword">True</span>, point_color=<span class="hljs-string">"black"</span>, 
                               point_size=<span class="hljs-number">4</span>, font_size=<span class="hljs-number">16</span>, shape=<span class="hljs-keyword">None</span>)
            plotter.set_background(<span class="hljs-string">'white'</span>)
            plotter.show(auto_close=<span class="hljs-keyword">False</span>)

            <span class="hljs-comment"># Run through each frame</span>
            <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces:
                surface.copy_from(surf)
                plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>
            <span class="hljs-comment"># Run through backwards</span>
            <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces[::<span class="hljs-number">-1</span>]:
                surface.copy_from(surf)
                plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>

            <span class="hljs-comment"># Be sure to close the plotter when finished</span>
            plotter.close()
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Error: gif_plot is only available for FES with 3 CVs."</span>)
        
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FEProfile</span>:</span>
    <span class="hljs-string">"""
    Free energy profile is a visualization of differences between local 
    minima points during metadynamics simulation. If the values seem 
    to converge to a mean value of the difference, it suggests, 
    but not fully prooves, that the obtained FES did converge to the correct shape.
    
    Command:
    ```python
    fep = metadynminer.FEProfile(minima, hillsfile)
    ```
    
    Parameters:
    
    * minima = metadynminer.Minima object
    
    * hillsfile = metadynminer.Hills object
    
    """</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, minima, hills)</span>:</span>
        self.cvs = minima.cvs
        self.res = minima.res
        self.minima = minima.minima
        self.periodic = minima.periodic
        self.heights = hills.get_heights()
        
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            self.cv1_name = minima.cv1_name
            self.cv1min = minima.cv1min
            self.cv1max = minima.cv1max
            self.cv1 = hills.get_cv1()
            self.s1 = hills.get_sigma1()
            self.cv1per = hills.get_cv1per()
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">2</span>:
            self.cv2min = minima.cv2min
            self.cv2max = minima.cv2max
            self.cv2_name = minima.cv2_name
            self.cv2 = hills.get_cv2()
            self.s2 = hills.get_sigma2()
            self.cv2per = hills.get_cv2per()
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            self.cv3min = minima.cv3min
            self.cv3max = minima.cv3max
            self.cv3_name = minima.cv3_name
            self.cv3 = hills.get_cv3()
            self.s3 = hills.get_sigma3()
            self.cv3per = hills.get_cv3per()
        
        <span class="hljs-keyword">if</span> len(minima.minima.shape)&gt;<span class="hljs-number">1</span>:
            self.makefeprofile(hills)
        <span class="hljs-keyword">else</span>: 
            print(<span class="hljs-string">"There is only one local minimum on the free energy surface."</span>)
        
        
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makefeprofile</span><span class="hljs-params">(self, hills)</span>:</span>
        <span class="hljs-string">"""
        Internal method to calculate free energy profile.
        """</span>
        hillslenght = len(hills.get_cv1())
        
        <span class="hljs-keyword">if</span> hillslenght &lt; <span class="hljs-number">256</span>:
            profilelenght = hillslenght
            scantimes = np.array(range(hillslenght))
        <span class="hljs-keyword">else</span>:
            profilelenght = <span class="hljs-number">256</span>
            scantimes = np.array(((hillslenght/(profilelenght))*np.array((range(<span class="hljs-number">1</span>,profilelenght+<span class="hljs-number">1</span>)))))
            scantimes -= <span class="hljs-number">1</span>
            scantimes = scantimes.astype(int)
        
        number_of_minima = self.minima.shape[<span class="hljs-number">0</span>]
        
        self.feprofile = np.zeros((self.minima.Minimum.shape[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>))
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>]
                cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv1range = self.cv1max-self.cv1min
                cv1min = self.cv1min
                cv1max = self.cv1max
                cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                cv1max += cv1range*<span class="hljs-number">0.15</span>
                cv1_fes_range = cv1max - cv1min
            
            fes = np.zeros((self.res))
            
            lasttime = <span class="hljs-number">0</span>
            line = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> scantimes:
                <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">3</span>]:
                    dist_cv1 = self.cv1[lasttime:time]-float(x)
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                        dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                        dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range

                    dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1[lasttime:time]**<span class="hljs-number">2</span>)
                    tmp = np.zeros(self.cv1[lasttime:time].shape)
                    tmp[dp2&lt;<span class="hljs-number">2.5</span>] = self.heights[lasttime:time][dp2&lt;<span class="hljs-number">2.5</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">2.5</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                    fes[int((float(x)-cv1min)*self.res/cv1_fes_range)] -= tmp.sum()

                profileline = [time]
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(number_of_minima):
                    profileline.append(fes[int(float(self.minima.iloc[m,<span class="hljs-number">2</span>]))]-\
                                       fes[int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]))])
                self.feprofile = np.vstack([self.feprofile, profileline])

                lasttime = time
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>]
                cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv1range = self.cv1max-self.cv1min
                cv1min = self.cv1min
                cv1max = self.cv1max
                cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                cv1max += cv1range*<span class="hljs-number">0.15</span>
                cv1_fes_range = cv1max - cv1min
                
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>]
                cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv2range = self.cv2max-self.cv2min
                cv2min = self.cv2min
                cv2max = self.cv2max
                cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                cv2max += cv2range*<span class="hljs-number">0.15</span>
                cv2_fes_range = cv2max - cv2min
            
            fes = np.zeros((self.res, self.res))
            
            lasttime = <span class="hljs-number">0</span>
            line = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> scantimes:
                <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">4</span>]:
                    dist_cv1 = self.cv1[lasttime:time]-float(x)
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                        dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                        dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                    
                    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">5</span>]:
                        dist_cv2 = self.cv2[lasttime:time]-float(y)
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                            dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                            dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                    
                        dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1[lasttime:time]**<span class="hljs-number">2</span>) + dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2[lasttime:time]**<span class="hljs-number">2</span>)
                        tmp = np.zeros(self.cv1[lasttime:time].shape)
                        tmp[dp2&lt;<span class="hljs-number">6.25</span>] = self.heights[lasttime:time][dp2&lt;<span class="hljs-number">6.25</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">6.25</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                        fes[int((float(x)-cv1min)*self.res/cv1_fes_range),int((float(y)-cv2min)*self.res/cv2_fes_range)] -= tmp.sum()
                
                <span class="hljs-comment"># save profile</span>
                profileline = [time]
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(number_of_minima):
                    profileline.append(fes[int(float(self.minima.iloc[m,<span class="hljs-number">2</span>])),int(float(self.minima.iloc[m,<span class="hljs-number">3</span>]))]-\
                                       fes[int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])),int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]))])
                self.feprofile = np.vstack([self.feprofile, profileline])

                lasttime = time
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>]
                cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv1range = self.cv1max-self.cv1min
                cv1min = self.cv1min
                cv1max = self.cv1max
                cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                cv1max += cv1range*<span class="hljs-number">0.15</span>
                cv1_fes_range = cv1max - cv1min
                
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>]
                cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv2range = self.cv2max-self.cv2min
                cv2min = self.cv2min
                cv2max = self.cv2max
                cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                cv2max += cv2range*<span class="hljs-number">0.15</span>
                cv2_fes_range = cv2max - cv2min
                
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">3</span>]:
                cv3min = self.cv3per[<span class="hljs-number">0</span>]
                cv3max = self.cv3per[<span class="hljs-number">1</span>]
                cv3_fes_range = np.abs(self.cv3per[<span class="hljs-number">1</span>]-self.cv3per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv3range = self.cv3max-self.cv3min
                cv3min = self.cv3min
                cv3max = self.cv3max
                cv3min -= cv3range*<span class="hljs-number">0.15</span>          
                cv3max += cv3range*<span class="hljs-number">0.15</span>
                cv3_fes_range = cv3max - cv3min
            
            fes = np.zeros((self.res, self.res, self.res))
            
            lasttime = <span class="hljs-number">0</span>
            line = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> scantimes:
                <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">5</span>]:
                    dist_cv1 = self.cv1[lasttime:time]-float(x)
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                        dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                        dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                    
                    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">6</span>]:
                        dist_cv2 = self.cv2[lasttime:time]-float(y)
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                            dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                            dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                        
                        <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">7</span>]:
                            dist_cv3 = self.cv3[lasttime:time]-float(z)
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                                dist_cv3[dist_cv3&lt;<span class="hljs-number">-0.5</span>*cv3_fes_range] += cv3_fes_range
                                dist_cv3[dist_cv3&gt;+<span class="hljs-number">0.5</span>*cv3_fes_range] -= cv3_fes_range
                    
                            dp2 = (dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1[lasttime:time]**<span class="hljs-number">2</span>) + 
                                   dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2[lasttime:time]**<span class="hljs-number">2</span>) + 
                                   dist_cv3**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s3[lasttime:time]**<span class="hljs-number">2</span>))
                            tmp = np.zeros(self.cv1[lasttime:time].shape)
                            tmp[dp2&lt;<span class="hljs-number">15.625</span>] = (self.heights[lasttime:time][dp2&lt;<span class="hljs-number">15.625</span>] * 
                                               (np.exp(-dp2[dp2&lt;<span class="hljs-number">15.625</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>))
                            fes[int((float(x)-cv1min)*self.res/cv1_fes_range),
                                int((float(y)-cv2min)*self.res/cv2_fes_range),
                                int((float(z)-cv3min)*self.res/cv3_fes_range)] -= tmp.sum()
                
                <span class="hljs-comment"># save profile</span>
                profileline = [time]
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(number_of_minima):
                    profileline.append(fes[int(float(self.minima.iloc[m,<span class="hljs-number">2</span>])),
                                           int(float(self.minima.iloc[m,<span class="hljs-number">3</span>])),
                                           int(float(self.minima.iloc[m,<span class="hljs-number">4</span>]))]-\
                                       fes[int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])),
                                           int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>])),
                                           int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]))])
                self.feprofile = np.vstack([self.feprofile, profileline])

                lasttime = time
            
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Fes object doesn't have supported number of CVs."</span>)
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span><span class="hljs-params">(self, png_name=None, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], xlabel=None, ylabel=None, label_size=<span class="hljs-number">12</span>, cmap=<span class="hljs-string">"jet"</span>)</span>:</span>
        <span class="hljs-string">"""
        Visualization function for free energy profiles. 
        
        ```python
        fep.plot(png_name="FEProfile.png")
        ```
        
        
        Parameters:
        
        
        * name (default="FEProfile.png") = name for .png file to save the plot to
        
        * image_size (default=[10,7]) = list of two dimensions of the picture
        
        * xlabel (default="time (ps)")
        
        * ylabel (default="free energy difference (kJ/mol)") 
        
        * label_size (default=12) = size of labels
        
        * cmap (default="jet") = matplotlib colormap used for coloring the line of the minima
        """</span>
        
        plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
        
        cmap=cm.get_cmap(cmap)
        
        <span class="hljs-comment">#colors = cm.jet((self.minima.iloc[:,1].to_numpy()).astype(float)/\</span>
        <span class="hljs-comment">#                (np.max(self.minima.iloc[:,1].to_numpy().astype(float))))</span>
        colors = cmap(np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,self.minima.shape[<span class="hljs-number">0</span>]))
        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(self.minima.shape[<span class="hljs-number">0</span>]):
            plt.plot(self.feprofile[:,<span class="hljs-number">0</span>], self.feprofile[:,m+<span class="hljs-number">1</span>], color=colors[m])

        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            plt.xlabel(<span class="hljs-string">'time (ps)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.xlabel(xlabel, size=label_size)
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            plt.ylabel(<span class="hljs-string">'free energy difference (kJ/mol)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.ylabel(ylabel, size=label_size)
        <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
            plt.savefig(png_name)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="metadynminer.FEProfile"><code class="flex name class">
<span>class <span class="ident">FEProfile</span></span>
<span>(</span><span>minima, hills)</span>
</code></dt>
<dd>
<div class="desc"><p>Free energy profile is a visualization of differences between local
minima points during metadynamics simulation. If the values seem
to converge to a mean value of the difference, it suggests,
but not fully prooves, that the obtained FES did converge to the correct shape.</p>
<p>Command:</p>
<pre><code class="language-python hljs">fep = metadynminer.FEProfile(minima, hillsfile)
</code></pre>
<p>Parameters:</p>
<ul>
<li>
<p>minima = metadynminer.Minima object</p>
</li>
<li>
<p>hillsfile = metadynminer.Hills object</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FEProfile</span>:</span>
    <span class="hljs-string">"""
    Free energy profile is a visualization of differences between local 
    minima points during metadynamics simulation. If the values seem 
    to converge to a mean value of the difference, it suggests, 
    but not fully prooves, that the obtained FES did converge to the correct shape.
    
    Command:
    ```python
    fep = metadynminer.FEProfile(minima, hillsfile)
    ```
    
    Parameters:
    
    * minima = metadynminer.Minima object
    
    * hillsfile = metadynminer.Hills object
    
    """</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, minima, hills)</span>:</span>
        self.cvs = minima.cvs
        self.res = minima.res
        self.minima = minima.minima
        self.periodic = minima.periodic
        self.heights = hills.get_heights()
        
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            self.cv1_name = minima.cv1_name
            self.cv1min = minima.cv1min
            self.cv1max = minima.cv1max
            self.cv1 = hills.get_cv1()
            self.s1 = hills.get_sigma1()
            self.cv1per = hills.get_cv1per()
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">2</span>:
            self.cv2min = minima.cv2min
            self.cv2max = minima.cv2max
            self.cv2_name = minima.cv2_name
            self.cv2 = hills.get_cv2()
            self.s2 = hills.get_sigma2()
            self.cv2per = hills.get_cv2per()
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            self.cv3min = minima.cv3min
            self.cv3max = minima.cv3max
            self.cv3_name = minima.cv3_name
            self.cv3 = hills.get_cv3()
            self.s3 = hills.get_sigma3()
            self.cv3per = hills.get_cv3per()
        
        <span class="hljs-keyword">if</span> len(minima.minima.shape)&gt;<span class="hljs-number">1</span>:
            self.makefeprofile(hills)
        <span class="hljs-keyword">else</span>: 
            print(<span class="hljs-string">"There is only one local minimum on the free energy surface."</span>)
        
        
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makefeprofile</span><span class="hljs-params">(self, hills)</span>:</span>
        <span class="hljs-string">"""
        Internal method to calculate free energy profile.
        """</span>
        hillslenght = len(hills.get_cv1())
        
        <span class="hljs-keyword">if</span> hillslenght &lt; <span class="hljs-number">256</span>:
            profilelenght = hillslenght
            scantimes = np.array(range(hillslenght))
        <span class="hljs-keyword">else</span>:
            profilelenght = <span class="hljs-number">256</span>
            scantimes = np.array(((hillslenght/(profilelenght))*np.array((range(<span class="hljs-number">1</span>,profilelenght+<span class="hljs-number">1</span>)))))
            scantimes -= <span class="hljs-number">1</span>
            scantimes = scantimes.astype(int)
        
        number_of_minima = self.minima.shape[<span class="hljs-number">0</span>]
        
        self.feprofile = np.zeros((self.minima.Minimum.shape[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>))
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>]
                cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv1range = self.cv1max-self.cv1min
                cv1min = self.cv1min
                cv1max = self.cv1max
                cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                cv1max += cv1range*<span class="hljs-number">0.15</span>
                cv1_fes_range = cv1max - cv1min
            
            fes = np.zeros((self.res))
            
            lasttime = <span class="hljs-number">0</span>
            line = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> scantimes:
                <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">3</span>]:
                    dist_cv1 = self.cv1[lasttime:time]-float(x)
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                        dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                        dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range

                    dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1[lasttime:time]**<span class="hljs-number">2</span>)
                    tmp = np.zeros(self.cv1[lasttime:time].shape)
                    tmp[dp2&lt;<span class="hljs-number">2.5</span>] = self.heights[lasttime:time][dp2&lt;<span class="hljs-number">2.5</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">2.5</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                    fes[int((float(x)-cv1min)*self.res/cv1_fes_range)] -= tmp.sum()

                profileline = [time]
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(number_of_minima):
                    profileline.append(fes[int(float(self.minima.iloc[m,<span class="hljs-number">2</span>]))]-\
                                       fes[int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]))])
                self.feprofile = np.vstack([self.feprofile, profileline])

                lasttime = time
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>]
                cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv1range = self.cv1max-self.cv1min
                cv1min = self.cv1min
                cv1max = self.cv1max
                cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                cv1max += cv1range*<span class="hljs-number">0.15</span>
                cv1_fes_range = cv1max - cv1min
                
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>]
                cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv2range = self.cv2max-self.cv2min
                cv2min = self.cv2min
                cv2max = self.cv2max
                cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                cv2max += cv2range*<span class="hljs-number">0.15</span>
                cv2_fes_range = cv2max - cv2min
            
            fes = np.zeros((self.res, self.res))
            
            lasttime = <span class="hljs-number">0</span>
            line = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> scantimes:
                <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">4</span>]:
                    dist_cv1 = self.cv1[lasttime:time]-float(x)
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                        dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                        dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                    
                    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">5</span>]:
                        dist_cv2 = self.cv2[lasttime:time]-float(y)
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                            dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                            dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                    
                        dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1[lasttime:time]**<span class="hljs-number">2</span>) + dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2[lasttime:time]**<span class="hljs-number">2</span>)
                        tmp = np.zeros(self.cv1[lasttime:time].shape)
                        tmp[dp2&lt;<span class="hljs-number">6.25</span>] = self.heights[lasttime:time][dp2&lt;<span class="hljs-number">6.25</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">6.25</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                        fes[int((float(x)-cv1min)*self.res/cv1_fes_range),int((float(y)-cv2min)*self.res/cv2_fes_range)] -= tmp.sum()
                
                <span class="hljs-comment"># save profile</span>
                profileline = [time]
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(number_of_minima):
                    profileline.append(fes[int(float(self.minima.iloc[m,<span class="hljs-number">2</span>])),int(float(self.minima.iloc[m,<span class="hljs-number">3</span>]))]-\
                                       fes[int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])),int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]))])
                self.feprofile = np.vstack([self.feprofile, profileline])

                lasttime = time
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>]
                cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv1range = self.cv1max-self.cv1min
                cv1min = self.cv1min
                cv1max = self.cv1max
                cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                cv1max += cv1range*<span class="hljs-number">0.15</span>
                cv1_fes_range = cv1max - cv1min
                
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>]
                cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv2range = self.cv2max-self.cv2min
                cv2min = self.cv2min
                cv2max = self.cv2max
                cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                cv2max += cv2range*<span class="hljs-number">0.15</span>
                cv2_fes_range = cv2max - cv2min
                
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">3</span>]:
                cv3min = self.cv3per[<span class="hljs-number">0</span>]
                cv3max = self.cv3per[<span class="hljs-number">1</span>]
                cv3_fes_range = np.abs(self.cv3per[<span class="hljs-number">1</span>]-self.cv3per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv3range = self.cv3max-self.cv3min
                cv3min = self.cv3min
                cv3max = self.cv3max
                cv3min -= cv3range*<span class="hljs-number">0.15</span>          
                cv3max += cv3range*<span class="hljs-number">0.15</span>
                cv3_fes_range = cv3max - cv3min
            
            fes = np.zeros((self.res, self.res, self.res))
            
            lasttime = <span class="hljs-number">0</span>
            line = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> scantimes:
                <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">5</span>]:
                    dist_cv1 = self.cv1[lasttime:time]-float(x)
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                        dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                        dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                    
                    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">6</span>]:
                        dist_cv2 = self.cv2[lasttime:time]-float(y)
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                            dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                            dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                        
                        <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">7</span>]:
                            dist_cv3 = self.cv3[lasttime:time]-float(z)
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                                dist_cv3[dist_cv3&lt;<span class="hljs-number">-0.5</span>*cv3_fes_range] += cv3_fes_range
                                dist_cv3[dist_cv3&gt;+<span class="hljs-number">0.5</span>*cv3_fes_range] -= cv3_fes_range
                    
                            dp2 = (dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1[lasttime:time]**<span class="hljs-number">2</span>) + 
                                   dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2[lasttime:time]**<span class="hljs-number">2</span>) + 
                                   dist_cv3**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s3[lasttime:time]**<span class="hljs-number">2</span>))
                            tmp = np.zeros(self.cv1[lasttime:time].shape)
                            tmp[dp2&lt;<span class="hljs-number">15.625</span>] = (self.heights[lasttime:time][dp2&lt;<span class="hljs-number">15.625</span>] * 
                                               (np.exp(-dp2[dp2&lt;<span class="hljs-number">15.625</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>))
                            fes[int((float(x)-cv1min)*self.res/cv1_fes_range),
                                int((float(y)-cv2min)*self.res/cv2_fes_range),
                                int((float(z)-cv3min)*self.res/cv3_fes_range)] -= tmp.sum()
                
                <span class="hljs-comment"># save profile</span>
                profileline = [time]
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(number_of_minima):
                    profileline.append(fes[int(float(self.minima.iloc[m,<span class="hljs-number">2</span>])),
                                           int(float(self.minima.iloc[m,<span class="hljs-number">3</span>])),
                                           int(float(self.minima.iloc[m,<span class="hljs-number">4</span>]))]-\
                                       fes[int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])),
                                           int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>])),
                                           int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]))])
                self.feprofile = np.vstack([self.feprofile, profileline])

                lasttime = time
            
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Fes object doesn't have supported number of CVs."</span>)
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span><span class="hljs-params">(self, png_name=None, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], xlabel=None, ylabel=None, label_size=<span class="hljs-number">12</span>, cmap=<span class="hljs-string">"jet"</span>)</span>:</span>
        <span class="hljs-string">"""
        Visualization function for free energy profiles. 
        
        ```python
        fep.plot(png_name="FEProfile.png")
        ```
        
        
        Parameters:
        
        
        * name (default="FEProfile.png") = name for .png file to save the plot to
        
        * image_size (default=[10,7]) = list of two dimensions of the picture
        
        * xlabel (default="time (ps)")
        
        * ylabel (default="free energy difference (kJ/mol)") 
        
        * label_size (default=12) = size of labels
        
        * cmap (default="jet") = matplotlib colormap used for coloring the line of the minima
        """</span>
        
        plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
        
        cmap=cm.get_cmap(cmap)
        
        <span class="hljs-comment">#colors = cm.jet((self.minima.iloc[:,1].to_numpy()).astype(float)/\</span>
        <span class="hljs-comment">#                (np.max(self.minima.iloc[:,1].to_numpy().astype(float))))</span>
        colors = cmap(np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,self.minima.shape[<span class="hljs-number">0</span>]))
        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(self.minima.shape[<span class="hljs-number">0</span>]):
            plt.plot(self.feprofile[:,<span class="hljs-number">0</span>], self.feprofile[:,m+<span class="hljs-number">1</span>], color=colors[m])

        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            plt.xlabel(<span class="hljs-string">'time (ps)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.xlabel(xlabel, size=label_size)
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            plt.ylabel(<span class="hljs-string">'free energy difference (kJ/mol)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.ylabel(ylabel, size=label_size)
        <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
            plt.savefig(png_name)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="metadynminer.FEProfile.makefeprofile"><code class="name flex">
<span>def <span class="ident">makefeprofile</span></span>(<span>self, hills)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal method to calculate free energy profile.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makefeprofile</span><span class="hljs-params">(self, hills)</span>:</span>
    <span class="hljs-string">"""
    Internal method to calculate free energy profile.
    """</span>
    hillslenght = len(hills.get_cv1())
    
    <span class="hljs-keyword">if</span> hillslenght &lt; <span class="hljs-number">256</span>:
        profilelenght = hillslenght
        scantimes = np.array(range(hillslenght))
    <span class="hljs-keyword">else</span>:
        profilelenght = <span class="hljs-number">256</span>
        scantimes = np.array(((hillslenght/(profilelenght))*np.array((range(<span class="hljs-number">1</span>,profilelenght+<span class="hljs-number">1</span>)))))
        scantimes -= <span class="hljs-number">1</span>
        scantimes = scantimes.astype(int)
    
    number_of_minima = self.minima.shape[<span class="hljs-number">0</span>]
    
    self.feprofile = np.zeros((self.minima.Minimum.shape[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>))
    
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
            cv1min = self.cv1per[<span class="hljs-number">0</span>]
            cv1max = self.cv1per[<span class="hljs-number">1</span>]
            cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">else</span>:
            cv1range = self.cv1max-self.cv1min
            cv1min = self.cv1min
            cv1max = self.cv1max
            cv1min -= cv1range*<span class="hljs-number">0.15</span>          
            cv1max += cv1range*<span class="hljs-number">0.15</span>
            cv1_fes_range = cv1max - cv1min
        
        fes = np.zeros((self.res))
        
        lasttime = <span class="hljs-number">0</span>
        line = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> scantimes:
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">3</span>]:
                dist_cv1 = self.cv1[lasttime:time]-float(x)
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                    dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range

                dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1[lasttime:time]**<span class="hljs-number">2</span>)
                tmp = np.zeros(self.cv1[lasttime:time].shape)
                tmp[dp2&lt;<span class="hljs-number">2.5</span>] = self.heights[lasttime:time][dp2&lt;<span class="hljs-number">2.5</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">2.5</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                fes[int((float(x)-cv1min)*self.res/cv1_fes_range)] -= tmp.sum()

            profileline = [time]
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(number_of_minima):
                profileline.append(fes[int(float(self.minima.iloc[m,<span class="hljs-number">2</span>]))]-\
                                   fes[int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]))])
            self.feprofile = np.vstack([self.feprofile, profileline])

            lasttime = time
        
    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
            cv1min = self.cv1per[<span class="hljs-number">0</span>]
            cv1max = self.cv1per[<span class="hljs-number">1</span>]
            cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">else</span>:
            cv1range = self.cv1max-self.cv1min
            cv1min = self.cv1min
            cv1max = self.cv1max
            cv1min -= cv1range*<span class="hljs-number">0.15</span>          
            cv1max += cv1range*<span class="hljs-number">0.15</span>
            cv1_fes_range = cv1max - cv1min
            
        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
            cv2min = self.cv2per[<span class="hljs-number">0</span>]
            cv2max = self.cv2per[<span class="hljs-number">1</span>]
            cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">else</span>:
            cv2range = self.cv2max-self.cv2min
            cv2min = self.cv2min
            cv2max = self.cv2max
            cv2min -= cv2range*<span class="hljs-number">0.15</span>          
            cv2max += cv2range*<span class="hljs-number">0.15</span>
            cv2_fes_range = cv2max - cv2min
        
        fes = np.zeros((self.res, self.res))
        
        lasttime = <span class="hljs-number">0</span>
        line = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> scantimes:
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">4</span>]:
                dist_cv1 = self.cv1[lasttime:time]-float(x)
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                    dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                
                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">5</span>]:
                    dist_cv2 = self.cv2[lasttime:time]-float(y)
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                        dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                        dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                
                    dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1[lasttime:time]**<span class="hljs-number">2</span>) + dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2[lasttime:time]**<span class="hljs-number">2</span>)
                    tmp = np.zeros(self.cv1[lasttime:time].shape)
                    tmp[dp2&lt;<span class="hljs-number">6.25</span>] = self.heights[lasttime:time][dp2&lt;<span class="hljs-number">6.25</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">6.25</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                    fes[int((float(x)-cv1min)*self.res/cv1_fes_range),int((float(y)-cv2min)*self.res/cv2_fes_range)] -= tmp.sum()
            
            <span class="hljs-comment"># save profile</span>
            profileline = [time]
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(number_of_minima):
                profileline.append(fes[int(float(self.minima.iloc[m,<span class="hljs-number">2</span>])),int(float(self.minima.iloc[m,<span class="hljs-number">3</span>]))]-\
                                   fes[int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])),int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]))])
            self.feprofile = np.vstack([self.feprofile, profileline])

            lasttime = time
        
    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
            cv1min = self.cv1per[<span class="hljs-number">0</span>]
            cv1max = self.cv1per[<span class="hljs-number">1</span>]
            cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">else</span>:
            cv1range = self.cv1max-self.cv1min
            cv1min = self.cv1min
            cv1max = self.cv1max
            cv1min -= cv1range*<span class="hljs-number">0.15</span>          
            cv1max += cv1range*<span class="hljs-number">0.15</span>
            cv1_fes_range = cv1max - cv1min
            
        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
            cv2min = self.cv2per[<span class="hljs-number">0</span>]
            cv2max = self.cv2per[<span class="hljs-number">1</span>]
            cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">else</span>:
            cv2range = self.cv2max-self.cv2min
            cv2min = self.cv2min
            cv2max = self.cv2max
            cv2min -= cv2range*<span class="hljs-number">0.15</span>          
            cv2max += cv2range*<span class="hljs-number">0.15</span>
            cv2_fes_range = cv2max - cv2min
            
        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">3</span>]:
            cv3min = self.cv3per[<span class="hljs-number">0</span>]
            cv3max = self.cv3per[<span class="hljs-number">1</span>]
            cv3_fes_range = np.abs(self.cv3per[<span class="hljs-number">1</span>]-self.cv3per[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">else</span>:
            cv3range = self.cv3max-self.cv3min
            cv3min = self.cv3min
            cv3max = self.cv3max
            cv3min -= cv3range*<span class="hljs-number">0.15</span>          
            cv3max += cv3range*<span class="hljs-number">0.15</span>
            cv3_fes_range = cv3max - cv3min
        
        fes = np.zeros((self.res, self.res, self.res))
        
        lasttime = <span class="hljs-number">0</span>
        line = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> scantimes:
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">5</span>]:
                dist_cv1 = self.cv1[lasttime:time]-float(x)
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                    dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                
                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">6</span>]:
                    dist_cv2 = self.cv2[lasttime:time]-float(y)
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                        dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                        dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                    
                    <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> self.minima.iloc[:,<span class="hljs-number">7</span>]:
                        dist_cv3 = self.cv3[lasttime:time]-float(z)
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                            dist_cv3[dist_cv3&lt;<span class="hljs-number">-0.5</span>*cv3_fes_range] += cv3_fes_range
                            dist_cv3[dist_cv3&gt;+<span class="hljs-number">0.5</span>*cv3_fes_range] -= cv3_fes_range
                
                        dp2 = (dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1[lasttime:time]**<span class="hljs-number">2</span>) + 
                               dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2[lasttime:time]**<span class="hljs-number">2</span>) + 
                               dist_cv3**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s3[lasttime:time]**<span class="hljs-number">2</span>))
                        tmp = np.zeros(self.cv1[lasttime:time].shape)
                        tmp[dp2&lt;<span class="hljs-number">15.625</span>] = (self.heights[lasttime:time][dp2&lt;<span class="hljs-number">15.625</span>] * 
                                           (np.exp(-dp2[dp2&lt;<span class="hljs-number">15.625</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>))
                        fes[int((float(x)-cv1min)*self.res/cv1_fes_range),
                            int((float(y)-cv2min)*self.res/cv2_fes_range),
                            int((float(z)-cv3min)*self.res/cv3_fes_range)] -= tmp.sum()
            
            <span class="hljs-comment"># save profile</span>
            profileline = [time]
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(number_of_minima):
                profileline.append(fes[int(float(self.minima.iloc[m,<span class="hljs-number">2</span>])),
                                       int(float(self.minima.iloc[m,<span class="hljs-number">3</span>])),
                                       int(float(self.minima.iloc[m,<span class="hljs-number">4</span>]))]-\
                                   fes[int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>])),
                                       int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>])),
                                       int(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]))])
            self.feprofile = np.vstack([self.feprofile, profileline])

            lasttime = time
        
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">"Fes object doesn't have supported number of CVs."</span>)</code></pre>
</details>
</dd>
<dt id="metadynminer.FEProfile.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, png_name=None, image_size=[10, 7], xlabel=None, ylabel=None, label_size=12, cmap='jet')</span>
</code></dt>
<dd>
<div class="desc"><p>Visualization function for free energy profiles. </p>
<pre><code class="language-python hljs">fep.plot(png_name=<span class="hljs-string">"FEProfile.png"</span>)
</code></pre>
<h2 id="parameters">Parameters</h2>
<ul>
<li>
<p>name (default="FEProfile.png") = name for .png file to save the plot to</p>
</li>
<li>
<p>image_size (default=[10,7]) = list of two dimensions of the picture</p>
</li>
<li>
<p>xlabel (default="time (ps)")</p>
</li>
<li>
<p>ylabel (default="free energy difference (kJ/mol)") </p>
</li>
<li>
<p>label_size (default=12) = size of labels</p>
</li>
<li>
<p>cmap (default="jet") = matplotlib colormap used for coloring the line of the minima</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span><span class="hljs-params">(self, png_name=None, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], xlabel=None, ylabel=None, label_size=<span class="hljs-number">12</span>, cmap=<span class="hljs-string">"jet"</span>)</span>:</span>
    <span class="hljs-string">"""
    Visualization function for free energy profiles. 
    
    ```python
    fep.plot(png_name="FEProfile.png")
    ```
    
    
    Parameters:
    
    
    * name (default="FEProfile.png") = name for .png file to save the plot to
    
    * image_size (default=[10,7]) = list of two dimensions of the picture
    
    * xlabel (default="time (ps)")
    
    * ylabel (default="free energy difference (kJ/mol)") 
    
    * label_size (default=12) = size of labels
    
    * cmap (default="jet") = matplotlib colormap used for coloring the line of the minima
    """</span>
    
    plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
    
    cmap=cm.get_cmap(cmap)
    
    <span class="hljs-comment">#colors = cm.jet((self.minima.iloc[:,1].to_numpy()).astype(float)/\</span>
    <span class="hljs-comment">#                (np.max(self.minima.iloc[:,1].to_numpy().astype(float))))</span>
    colors = cmap(np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,self.minima.shape[<span class="hljs-number">0</span>]))
    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(self.minima.shape[<span class="hljs-number">0</span>]):
        plt.plot(self.feprofile[:,<span class="hljs-number">0</span>], self.feprofile[:,m+<span class="hljs-number">1</span>], color=colors[m])

    <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
        plt.xlabel(<span class="hljs-string">'time (ps)'</span>, size=label_size)
    <span class="hljs-keyword">else</span>:
        plt.xlabel(xlabel, size=label_size)
    <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
        plt.ylabel(<span class="hljs-string">'free energy difference (kJ/mol)'</span>, size=label_size)
    <span class="hljs-keyword">else</span>:
        plt.ylabel(ylabel, size=label_size)
    <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
        plt.savefig(png_name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="metadynminer.Fes"><code class="flex name class">
<span>class <span class="ident">Fes</span></span>
<span>(</span><span>hills=None, resolution=256, original=False, calculate_new_fes=True, cv1range=None, cv2range=None, cv3range=None, time_min=0, time_max=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object of this class is created to compute the free energy surface corresponding to the provided Hills object.
Command:</p>
<pre><code class="language-python hljs">fes = metadynminer.Fes(hills=hillsfile)
</code></pre>
<p>parameters:</p>
<ul>
<li>
<p>hills = Hills object</p>
</li>
<li>
<p>resolution (default=256) = should be positive integer, controls the resolution of FES</p>
</li>
<li>
<p>original (default=False) = boolean, if False, FES will be calculated using very fast, but not
'exact' Bias Sum Algorithm
if True, FES will be calculated with slower algorithm, but it will be exactly the same as FES calculated
with PLUMED sum_hills function</p>
</li>
<li>
<p>cv1range, cv2range, cv3range = lists of two numbers, defining lower and upper bound of the respective CV (in the units of the CVs)</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fes</span>:</span> 
    <span class="hljs-string">"""
    Object of this class is created to compute the free energy surface corresponding to the provided Hills object. 
    Command:
    ```python
    fes = metadynminer.Fes(hills=hillsfile)
    ```
    parameters:
    
    * hills = Hills object
    
    * resolution (default=256) = should be positive integer, controls the resolution of FES
    
    * original (default=False) = boolean, if False, FES will be calculated using very fast, but not
    'exact' Bias Sum Algorithm
                                        if True, FES will be calculated with slower algorithm, but it will be exactly the same as FES calculated 
                                        with PLUMED sum_hills function
                                        
    * cv1range, cv2range, cv3range = lists of two numbers, defining lower and upper bound of the respective CV (in the units of the CVs)
    """</span>
    
    __pdoc__[<span class="hljs-string">"Fes.makefes"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Fes.makefes2"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Fes.set_fes"</span>] = <span class="hljs-keyword">False</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, hills=None, resolution=<span class="hljs-number">256</span>, original=False, \
                 calculate_new_fes=True, cv1range=None, cv2range=None, cv3range=None, \
                 time_min=<span class="hljs-number">0</span>, time_max=None)</span>:</span>
        self.res = resolution
        self.cv1range = cv1range
        self.cv2range = cv2range
        self.cv3range = cv3range
        <span class="hljs-keyword">if</span> hills != <span class="hljs-keyword">None</span>:
            self.hills = hills
            self.cvs = hills.get_number_of_cvs()
            self.heights = hills.get_heights()
            self.periodic = hills.get_periodic()
            self.biasf = hills.biasf
            
            <span class="hljs-keyword">if</span> cv1range!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> len(cv1range) != <span class="hljs-number">2</span>:
                print(<span class="hljs-string">"Error: You have to specify CV1 range as a list of two values. "</span>)
            <span class="hljs-keyword">if</span> cv2range!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> len(cv2range) != <span class="hljs-number">2</span>:
                print(<span class="hljs-string">"Error: You have to specify CV2 range as a list of two values. "</span>)
            <span class="hljs-keyword">if</span> cv3range!=<span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> len(cv3range) != <span class="hljs-number">2</span>:
                print(<span class="hljs-string">"Error: You have to specify CV3 range as a list of two values. "</span>)
            
            <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
                self.cv1 = hills.get_cv1()
                self.s1 = hills.get_sigma1()

                self.cv1min = np.min(self.cv1) - <span class="hljs-number">1e-8</span>
                self.cv1max = np.max(self.cv1) + <span class="hljs-number">1e-8</span>

                self.cv1_name = hills.get_cv1_name()
                self.cv1per = hills.get_cv1per()
                
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> original:
                    <span class="hljs-keyword">if</span> ((np.max(self.s1)/np.min(self.s1))&gt;<span class="hljs-number">1.00000001</span>):
                        print(<span class="hljs-string">"""Error: Bias sum algorithm only works for hills files 
                        in which all hills have the same width. 
                        For this file, you need the slower but exact, algorithm, to do that, 
                        set the argument 'original' to True."""</span>)

            <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">2</span>:
                self.cv2 = hills.get_cv2()
                self.s2 = hills.get_sigma2()

                self.cv2min = np.min(self.cv2) - <span class="hljs-number">1e-8</span>
                self.cv2max = np.max(self.cv2) + <span class="hljs-number">1e-8</span>

                self.cv2_name = hills.get_cv2_name()
                self.cv2per = hills.get_cv2per()
                
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> original:
                    <span class="hljs-keyword">if</span> ((np.max(self.s2)/np.min(self.s2))&gt;<span class="hljs-number">1.00000001</span>):
                        print(<span class="hljs-string">"""Error: Bias sum algorithm only works for hills files 
                        in which all hills have the same width. 
                        For this file, you need the slower but exact, algorithm, to do that, 
                        set the argument 'original' to True."""</span>)

            <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
                self.cv3 = hills.get_cv3()
                self.s3 = hills.get_sigma3()

                self.cv3min = np.min(self.cv3) - <span class="hljs-number">1e-8</span>
                self.cv3max = np.max(self.cv3) + <span class="hljs-number">1e-8</span>

                self.cv3_name = hills.get_cv3_name()
                self.cv3per = hills.get_cv3per()
                
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> original:
                    <span class="hljs-keyword">if</span> ((np.max(self.s3)/np.min(self.s3))&gt;<span class="hljs-number">1.00000001</span>):
                        print(<span class="hljs-string">"""Error: Bias sum algorithm only works for hills files 
                        in which all hills have the same width of given CV. 
                        For this file, you need the slower but exact, algorithm, to do that, 
                        set the argument 'original' to True."""</span>)
            <span class="hljs-keyword">if</span> time_max != <span class="hljs-keyword">None</span>:     
                <span class="hljs-keyword">if</span> time_max &lt;= time_min:
                    print(<span class="hljs-string">"Error: End time is lower than start time"</span>)
                <span class="hljs-keyword">if</span> time_max &gt; len(self.cv1):
                    time_max = len(self.cv1)
                    print(<span class="hljs-string">f"Error: End time <span class="hljs-subst">{time_max}</span> is higher than number of lines in HILLS file <span class="hljs-subst">{len(self.cv1)}</span>, which will be used instead. "</span>)
            
            <span class="hljs-keyword">if</span> calculate_new_fes:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> original:
                    self.makefes(resolution, cv1range, cv2range, cv3range, time_min, time_max)
                <span class="hljs-keyword">else</span>:
                    self.makefes2(resolution, cv1range, cv2range, cv3range, time_min, time_max)
                        
        
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makefes</span><span class="hljs-params">(self, resolution, cv1range, cv2range, cv3range, time_min, time_max)</span>:</span>
        <span class="hljs-string">"""
        Function used internally for summing hills in Hills object with the fast Bias Sum Algorithm. 
        """</span>
        self.res = resolution
        <span class="hljs-comment">#if self.res % 2 == 0:</span>
        <span class="hljs-comment">#    self.res += 1</span>
                
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> cv1range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1range = self.cv1max-self.cv1min
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
            cv1_fes_range = cv1max-cv1min
                
            cv1bin = np.ceil((self.cv1-cv1min)*(self.res)/(cv1_fes_range))
            cv1bin = cv1bin.astype(int)
            s1res = (self.s1[<span class="hljs-number">0</span>]*self.res)/(cv1max - cv1min)
            self.cv1bin = cv1bin
            gauss_res = <span class="hljs-number">8</span>*s1res
            gauss_res = int(gauss_res)
            <span class="hljs-keyword">if</span> gauss_res%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
                gauss_res += <span class="hljs-number">1</span>
            
            gauss_center = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>
            gauss = np.zeros((gauss_res))
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gauss_res):
                <span class="hljs-comment">#dp2 = ((i+1)-gauss_center)**2/(2*s1res**2)</span>
                <span class="hljs-comment">#if dp2 &lt; 6.25:</span>
                <span class="hljs-comment">#    gauss[int(i)] = -np.exp(-dp2) * 1.00193418799744762399 - 0.00193418799744762399</span>
                gauss[int(i)] = -np.exp(-((i+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s1res**<span class="hljs-number">2</span>))
                
            fes = np.zeros((self.res))
            
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(cv1bin)):
                <span class="hljs-keyword">if</span> (line) % <span class="hljs-number">500</span> == <span class="hljs-number">0</span>:
                    print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{((line+<span class="hljs-number">1</span>)/len(cv1bin)):<span class="hljs-number">.1</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                
                <span class="hljs-comment">#fes_center = int((self.res-1)/2)</span>
                gauss_center_to_end = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)
                
                fes_to_edit_cv1 = [cv1bin[line]<span class="hljs-number">-1</span>-gauss_center_to_end,
                                   cv1bin[line]<span class="hljs-number">-1</span>+gauss_center_to_end]
                fes_crop_cv1 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv1[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv1[<span class="hljs-number">1</span>])]
                
                gauss_crop_cv1 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv1bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv1bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                
                fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    <span class="hljs-keyword">if</span> cv1bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv1_p = [self.res<span class="hljs-number">-1</span>+(cv1bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv1bin[line]]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv1bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv1bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [gauss_res-(gauss_center_to_end+cv1bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
            print(<span class="hljs-string">"\n"</span>)
            fes = fes-np.min(fes)
            self.fes = np.array(fes)
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> cv1range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1range = self.cv1max-self.cv1min
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
            cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2range = self.cv2max-self.cv2min
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = cv2range[<span class="hljs-number">0</span>]
                cv2max = cv2range[<span class="hljs-number">1</span>]
                self.cv2range = cv2range
            cv2_fes_range = cv2max-cv2min
            
            cv1bin = np.ceil((self.cv1-cv1min)*self.res/(cv1max-cv1min))
            cv2bin = np.ceil((self.cv2-cv2min)*self.res/(cv2max-cv2min))
                        
            cv1bin = cv1bin.astype(int)
            cv2bin = cv2bin.astype(int)
            
            s1res = (self.s1[<span class="hljs-number">0</span>]*self.res)/(cv1max - cv1min)
            s2res = (self.s2[<span class="hljs-number">0</span>]*self.res)/(cv2max - cv2min)
            
            gauss_res = max(<span class="hljs-number">8</span>*s1res, <span class="hljs-number">8</span>*s2res)
            gauss_res = int(gauss_res)
            <span class="hljs-keyword">if</span> gauss_res%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
                gauss_res += <span class="hljs-number">1</span>
            
            gauss_center = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>
            gauss = np.zeros((gauss_res,gauss_res))
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gauss_res):
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(gauss_res):
                    <span class="hljs-comment">#dp2 = ((i+1)-gauss_center)**2/(2*s1res**2) + ((j+1)-gauss_center)**2/(2*s2res**2)</span>
                    <span class="hljs-comment">#if dp2 &lt; 6.25:</span>
                    <span class="hljs-comment">#    gauss[int(i), int(j)] = -np.exp(-dp2) * 1.00193418799744762399 - 0.00193418799744762399</span>
                    gauss[int(i), int(j)] = -np.exp(-(((i+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s1res**<span class="hljs-number">2</span>) + ((j+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s2res**<span class="hljs-number">2</span>)))
            
            fes = np.zeros((self.res,self.res))
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(cv1bin)):
                <span class="hljs-keyword">if</span> (line) % <span class="hljs-number">500</span> == <span class="hljs-number">0</span>:
                    print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{((line+<span class="hljs-number">1</span>)/len(cv1bin)):<span class="hljs-number">.1</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                
                <span class="hljs-comment">#fes_center = int((self.res-1)/2)</span>
                gauss_center_to_end = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)
                <span class="hljs-comment">#print(f"\ng_res: {gauss_res}, gauss_center_to_end: {gauss_center_to_end}")</span>
                
                fes_to_edit_cv1 = [cv1bin[line]<span class="hljs-number">-1</span>-gauss_center_to_end,
                                   cv1bin[line]<span class="hljs-number">-1</span>+gauss_center_to_end]
                fes_to_edit_cv2 = [cv2bin[line]<span class="hljs-number">-1</span>-gauss_center_to_end,
                                   cv2bin[line]<span class="hljs-number">-1</span>+gauss_center_to_end]
                fes_crop_cv1 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv1[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv1[<span class="hljs-number">1</span>])]
                fes_crop_cv2 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv2[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv2[<span class="hljs-number">1</span>])]
                
                gauss_crop_cv1 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv1bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv1bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                gauss_crop_cv2 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv2bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv2bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                
                fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    <span class="hljs-keyword">if</span> cv1bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv1_p = [self.res<span class="hljs-number">-1</span>+(cv1bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv1bin[line]]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv1bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv1bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [gauss_res-(gauss_center_to_end+cv1bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">if</span> cv2bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv2_p = [self.res<span class="hljs-number">-1</span>+(cv2bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv2_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv2bin[line]]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv2bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv2_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv2bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv2_p = [gauss_res-(gauss_center_to_end+cv2bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">if</span> ((cv1bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv1bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv2bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv2bin[line] &gt; (self.res-gauss_center_to_end))):
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
            print(<span class="hljs-string">"\n"</span>)
            fes = fes-np.min(fes)
            self.fes = np.array(fes)
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> cv1range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1range = self.cv1max-self.cv1min
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
            cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2range = self.cv2max-self.cv2min
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = cv2range[<span class="hljs-number">0</span>]
                cv2max = cv2range[<span class="hljs-number">1</span>]
                self.cv2range = cv2range
            cv2_fes_range = cv2max-cv2min
            
            <span class="hljs-keyword">if</span> cv3range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                    cv3min = self.cv3per[<span class="hljs-number">0</span>]
                    cv3max = self.cv3per[<span class="hljs-number">1</span>]
                <span class="hljs-keyword">else</span>:
                    cv3min = self.cv3min
                    cv3max = self.cv3max
                    cv3range = self.cv3max-self.cv3min
                    cv3min -= cv3range*<span class="hljs-number">0.15</span>          
                    cv3max += cv3range*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = cv3range[<span class="hljs-number">0</span>]
                cv3max = cv3range[<span class="hljs-number">1</span>]
                self.cv3range = cv3range
            cv3_fes_range = cv3max-cv3min
            
            cv1bin = np.ceil((self.cv1-cv1min)*self.res/(cv1max-cv1min))
            cv2bin = np.ceil((self.cv2-cv2min)*self.res/(cv2max-cv2min))
            cv3bin = np.ceil((self.cv3-cv3min)*self.res/(cv3max-cv3min))
                        
            cv1bin = cv1bin.astype(int)
            cv2bin = cv2bin.astype(int)
            cv3bin = cv3bin.astype(int)
            
            s1res = (self.s1[<span class="hljs-number">0</span>]*self.res)/(cv1max - cv1min)
            s2res = (self.s2[<span class="hljs-number">0</span>]*self.res)/(cv2max - cv2min)
            s3res = (self.s3[<span class="hljs-number">0</span>]*self.res)/(cv3max - cv3min)
            
            gauss_res = max(<span class="hljs-number">10</span>*s1res, <span class="hljs-number">10</span>*s2res, <span class="hljs-number">10</span>*s3res)
            gauss_res = int(gauss_res)
            <span class="hljs-keyword">if</span> gauss_res%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
                gauss_res += <span class="hljs-number">1</span>
            gauss_center = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>
            gauss = np.zeros((gauss_res,gauss_res,gauss_res))
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(gauss_res):
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(gauss_res):
                    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(gauss_res):
                        <span class="hljs-comment">#dp2 = ((i+1)-gauss_center)**2/(2*s1res**2) + ((j+1)-gauss_center)**2/(2*s2res**2) + ((k+1)-gauss_center)**2/(2*s3res**2)</span>
                        <span class="hljs-comment">#if dp2 &lt; 6.25:</span>
                        <span class="hljs-comment">#    gauss[int(i), int(j), int(k)] = -np.exp(-dp2) * 1.00193418799744762399 - 0.00193418799744762399</span>
                        gauss[int(i), int(j), int(k)] = -np.exp(-(((i+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s1res**<span class="hljs-number">2</span>) + 
                                                                  ((j+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s2res**<span class="hljs-number">2</span>) + 
                                                                  ((k+<span class="hljs-number">1</span>)-gauss_center)**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*s3res**<span class="hljs-number">2</span>)))
            
            fes = np.zeros((self.res, self.res, self.res))
            
            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(cv1bin)):
                <span class="hljs-keyword">if</span> (line) % <span class="hljs-number">500</span> == <span class="hljs-number">0</span>:
                    print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{((line+<span class="hljs-number">1</span>)/len(cv1bin)):<span class="hljs-number">.1</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                
                <span class="hljs-comment">#fes_center = int((self.res-1)/2)</span>
                gauss_center_to_end = int((gauss_res<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>)
                
                fes_to_edit_cv1 = [cv1bin[line]<span class="hljs-number">-1</span>-gauss_center_to_end,
                                   cv1bin[line]<span class="hljs-number">-1</span>+gauss_center_to_end]
                fes_to_edit_cv2 = [(cv2bin[line]<span class="hljs-number">-1</span>)-gauss_center_to_end,
                                   (cv2bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end]
                fes_to_edit_cv3 = [(cv3bin[line]<span class="hljs-number">-1</span>)-gauss_center_to_end,
                                   (cv3bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end]
                fes_crop_cv1 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv1[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv1[<span class="hljs-number">1</span>])]
                fes_crop_cv2 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv2[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv2[<span class="hljs-number">1</span>])]
                fes_crop_cv3 = [max(<span class="hljs-number">0</span>,fes_to_edit_cv3[<span class="hljs-number">0</span>]),min(self.res<span class="hljs-number">-1</span>,fes_to_edit_cv3[<span class="hljs-number">1</span>])]
                
                gauss_crop_cv1 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv1bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv1bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                gauss_crop_cv2 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv2bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv2bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                gauss_crop_cv3 = [max(<span class="hljs-number">0</span>,gauss_center_to_end-(cv3bin[line]<span class="hljs-number">-1</span>)),
                                      gauss_res<span class="hljs-number">-1</span>-max(<span class="hljs-number">0</span>,(cv3bin[line]<span class="hljs-number">-1</span>)+gauss_center_to_end-self.res+<span class="hljs-number">1</span>)]
                
                fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                    fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                    fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                 gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                 gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                        * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    <span class="hljs-keyword">if</span> cv1bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv1_p = [self.res<span class="hljs-number">-1</span>+(cv1bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv1bin[line]]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv1bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv1_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv1bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv1_p = [gauss_res-(gauss_center_to_end+cv1bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">if</span> cv2bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv2_p = [self.res<span class="hljs-number">-1</span>+(cv2bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv2_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv2bin[line]]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv2bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv2_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv2bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv2_p = [gauss_res-(gauss_center_to_end+cv2bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                    <span class="hljs-keyword">if</span> cv3bin[line] &lt; gauss_center_to_end:
                        fes_crop_cv3_p = [self.res<span class="hljs-number">-1</span>+(cv3bin[line]-gauss_center_to_end),self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv3_p = [<span class="hljs-number">0</span>,gauss_center_to_end-cv3bin[line]]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                    
                    <span class="hljs-keyword">if</span> cv3bin[line] &gt; (self.res-gauss_center_to_end):
                        fes_crop_cv3_p = [<span class="hljs-number">0</span>,gauss_center_to_end+cv3bin[line]-self.res<span class="hljs-number">-1</span>]
                        gauss_crop_cv3_p = [gauss_res-(gauss_center_to_end+cv3bin[line]-self.res),gauss_res<span class="hljs-number">-1</span>]
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">1</span>]:
                    <span class="hljs-keyword">if</span> ((cv1bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv1bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv2bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv2bin[line] &gt; (self.res-gauss_center_to_end))):
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3[<span class="hljs-number">0</span>]:fes_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3[<span class="hljs-number">0</span>]:gauss_crop_cv3[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">2</span>]:
                    <span class="hljs-keyword">if</span> ((cv1bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv1bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv3bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv3bin[line] &gt; (self.res-gauss_center_to_end))):
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2[<span class="hljs-number">0</span>]:fes_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2[<span class="hljs-number">0</span>]:gauss_crop_cv2[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">2</span>]:
                    <span class="hljs-keyword">if</span> ((cv2bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv2bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv3bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv3bin[line] &gt; (self.res-gauss_center_to_end))):
                        fes[fes_crop_cv1[<span class="hljs-number">0</span>]:fes_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1[<span class="hljs-number">0</span>]:gauss_crop_cv1[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
                
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> self.periodic[<span class="hljs-number">2</span>]:
                    <span class="hljs-keyword">if</span> ((cv1bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv1bin[line] &gt; (self.res-gauss_center_to_end)))\
                            <span class="hljs-keyword">and</span> ((cv2bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv2bin[line] &gt; (self.res-gauss_center_to_end))) \
                            <span class="hljs-keyword">and</span> ((cv3bin[line] &lt; gauss_center_to_end) <span class="hljs-keyword">or</span> (cv3bin[line] &gt; (self.res-gauss_center_to_end))) :
                        fes[fes_crop_cv1_p[<span class="hljs-number">0</span>]:fes_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv2_p[<span class="hljs-number">0</span>]:fes_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                            fes_crop_cv3_p[<span class="hljs-number">0</span>]:fes_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    += gauss[gauss_crop_cv1_p[<span class="hljs-number">0</span>]:gauss_crop_cv1_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv2_p[<span class="hljs-number">0</span>]:gauss_crop_cv2_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>,\
                                             gauss_crop_cv3_p[<span class="hljs-number">0</span>]:gauss_crop_cv3_p[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>]\
                                    * self.heights[line]
            
            print(<span class="hljs-string">"\n"</span>)
            fes = fes-np.min(fes)
            self.fes = np.array(fes)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Fes object doesn't have supported number of CVs."</span>)
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">makefes2</span><span class="hljs-params">(self, resolution, cv1range, cv2range, cv3range, time_min, time_max)</span>:</span>
        <span class="hljs-string">"""
        Function internally used to sum Hills in the same way as Plumed sum_hills. 
        """</span>
        
        self.res = resolution
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> cv1range==<span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                    cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv1range = self.cv1max-self.cv1min
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
                    cv1_fes_range = cv1max - cv1min
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
                cv1_fes_range = cv1max-cv1min
            
            fes = np.zeros((self.res))
            
            progress = <span class="hljs-number">0</span>
            max_progress = self.res ** self.cvs
            
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(self.res):
                progress += <span class="hljs-number">1</span>
                <span class="hljs-keyword">if</span> (progress) % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:
                    print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{(progress/max_progress):<span class="hljs-number">.2</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                
                dist_cv1 = self.cv1-(cv1min+(x)*cv1_fes_range/(self.res))
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                    dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                
                dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1**<span class="hljs-number">2</span>)
                tmp = np.zeros(self.cv1.shape)
                tmp[dp2&lt;<span class="hljs-number">6.25</span>] = self.heights[dp2&lt;<span class="hljs-number">6.25</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">6.25</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                fes[x] = -tmp.sum()
                    
            fes = fes - np.min(fes)
            self.fes = np.array(fes)
            print(<span class="hljs-string">"\n"</span>)
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> cv1range==<span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                    cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv1range = self.cv1max-self.cv1min
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
                    cv1_fes_range = cv1max - cv1min
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
                cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                    cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv2range = self.cv2max-self.cv2min
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
                    cv2_fes_range = cv2max - cv2min
            <span class="hljs-keyword">else</span>:
                cv2min = cv2range[<span class="hljs-number">0</span>]
                cv2max = cv2range[<span class="hljs-number">1</span>]
                self.cv2range = cv2range
                cv2_fes_range = cv2max-cv2min
            
            fes = np.zeros((self.res, self.res))
            
            progress = <span class="hljs-number">0</span>
            max_progress = self.res ** self.cvs
            
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(self.res):
                dist_cv1 = self.cv1-(cv1min+(x)*cv1_fes_range/(self.res))
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                    dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                    
                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(self.res):
                    progress += <span class="hljs-number">1</span>
                    <span class="hljs-keyword">if</span> (progress) % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:
                        print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{(progress/max_progress):<span class="hljs-number">.2</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                    
                    dist_cv2 = self.cv2-(cv2min+(y)*cv2_fes_range/(self.res))
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                        dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                        dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                        
                    dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1**<span class="hljs-number">2</span>) + dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2**<span class="hljs-number">2</span>)
                    tmp = np.zeros(self.cv1.shape)
                    tmp[dp2&lt;<span class="hljs-number">6.25</span>] = self.heights[dp2&lt;<span class="hljs-number">6.25</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">6.25</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                    fes[x,y] = -tmp.sum()
                    
            fes = fes - np.min(fes)
            self.fes = np.array(fes)
            print(<span class="hljs-string">"\n"</span>)
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> cv1range==<span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                    cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv1range = self.cv1max-self.cv1min
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
                    cv1_fes_range = cv1max - cv1min
            <span class="hljs-keyword">else</span>:
                cv1min = cv1range[<span class="hljs-number">0</span>]
                cv1max = cv1range[<span class="hljs-number">1</span>]
                self.cv1range = cv1range
                cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                    cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv2range = self.cv2max-self.cv2min
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
                    cv2_fes_range = cv2max - cv2min
            <span class="hljs-keyword">else</span>:
                cv2min = cv2range[<span class="hljs-number">0</span>]
                cv2max = cv2range[<span class="hljs-number">1</span>]
                self.cv2range = cv2range
                cv2_fes_range = cv2max-cv2min
            
            <span class="hljs-keyword">if</span> cv3range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                    cv3min = self.cv3per[<span class="hljs-number">0</span>]
                    cv3max = self.cv3per[<span class="hljs-number">1</span>]
                    cv3_fes_range = np.abs(self.cv3per[<span class="hljs-number">1</span>]-self.cv3per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv3range = self.cv3max-self.cv3min
                    cv3min = self.cv3min
                    cv3max = self.cv3max
                    cv3min -= cv3range*<span class="hljs-number">0.15</span>          
                    cv3max += cv3range*<span class="hljs-number">0.15</span>
                    cv3_fes_range = cv3max - cv3min
            <span class="hljs-keyword">else</span>:
                cv3min = cv3range[<span class="hljs-number">0</span>]
                cv3max = cv3range[<span class="hljs-number">1</span>]
                self.cv3range = cv3range
                cv3_fes_range = cv3max-cv3min
            
            fes = np.zeros((self.res, self.res, self.res))
            
            progress = <span class="hljs-number">0</span>
            max_progress = self.res ** self.cvs
            
            <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(self.res):
                dist_cv1 = self.cv1-(cv1min+(x)*cv1_fes_range/(self.res))
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    dist_cv1[dist_cv1&lt;<span class="hljs-number">-0.5</span>*cv1_fes_range] += cv1_fes_range
                    dist_cv1[dist_cv1&gt;+<span class="hljs-number">0.5</span>*cv1_fes_range] -= cv1_fes_range
                    
                <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(self.res):
                    dist_cv2 = self.cv2-(cv2min+(y)*cv2_fes_range/(self.res))
                    <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                        dist_cv2[dist_cv2&lt;<span class="hljs-number">-0.5</span>*cv2_fes_range] += cv2_fes_range
                        dist_cv2[dist_cv2&gt;+<span class="hljs-number">0.5</span>*cv2_fes_range] -= cv2_fes_range
                        
                    <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> range(self.res):
                        progress += <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> (progress) % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:
                            print(<span class="hljs-string">f"Constructing free energy surface: <span class="hljs-subst">{(progress/max_progress):<span class="hljs-number">.2</span>%}</span> finished"</span>, end=<span class="hljs-string">"\r"</span>)
                        
                        dist_cv3 = self.cv3-(cv3min+(z)*cv3_fes_range/(self.res))
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                            dist_cv3[dist_cv3&lt;<span class="hljs-number">-0.5</span>*cv3_fes_range] += cv3_fes_range
                            dist_cv3[dist_cv3&gt;+<span class="hljs-number">0.5</span>*cv3_fes_range] -= cv3_fes_range
                        
                        dp2 = dist_cv1**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s1**<span class="hljs-number">2</span>) + dist_cv2**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s2**<span class="hljs-number">2</span>) + dist_cv3**<span class="hljs-number">2</span>/(<span class="hljs-number">2</span>*self.s3**<span class="hljs-number">2</span>)
                        tmp = np.zeros(self.cv1.shape)
                        tmp[dp2&lt;<span class="hljs-number">6.25</span>] = self.heights[dp2&lt;<span class="hljs-number">6.25</span>] * (np.exp(-dp2[dp2&lt;<span class="hljs-number">6.25</span>]) * <span class="hljs-number">1.00193418799744762399</span> - <span class="hljs-number">0.00193418799744762399</span>)
                        fes[x,y,z] = -tmp.sum()
                        
                        
                    
            fes = fes - np.min(fes)
            self.fes = np.array(fes)
            print(<span class="hljs-string">"\n"</span>)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">f"Error: unsupported number of CVs: <span class="hljs-subst">{self.cvs}</span>."</span>)
        
    
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span><span class="hljs-params">(self, png_name=None, contours=True, contours_spacing=<span class="hljs-number">0.0</span>, aspect = <span class="hljs-number">1.0</span>, cmap = <span class="hljs-string">"jet"</span>, 
                 energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
                 vmin = <span class="hljs-number">0</span>, vmax = None, opacity=<span class="hljs-number">0.2</span>, levels=None)</span>:</span>
        <span class="hljs-string">"""
        Function used to visualize FES, based on Matplotlib and PyVista. 
        
        ```python
        fes.plot(png_name="fes.png")
        ```
        
        Parameters:
        
        * png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.
        
        * contours (default=True) = whether contours should be shown on 2D FES
        
        * contours_spacing (default=0.0) = when a positive number is set, it will be used as spacing for contours on 2D FES. 
                Otherwise, if contours=True, there will be five equally spaced contour levels.
        
        * aspect (default = 1.0) = aspect ratio of the graph. Works with 1D and 2D FES. 
        
        * cmap (default = "jet") = Matplotlib colormap used to color 2D or 3D FES
        
        * energy_unit (default="kJ/mol") = String, used in description of colorbar
        
        * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graphs
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        * vmin (default=0) = real number, lower bound for the colormap on 2D FES
        
        * vmax = real number, upper bound for the colormap on 2D FES
        
        * opacity (default=0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
        
        * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
                        If not provided, default values from contours parameters will be used instead. 
        """</span>
        <span class="hljs-keyword">if</span> vmax == <span class="hljs-keyword">None</span>:
            vmax = np.max(self.fes)+<span class="hljs-number">0.01</span> <span class="hljs-comment"># if the addition is smaller than 0.01, the 3d plot stops working. </span>
            
        <span class="hljs-keyword">if</span> contours_spacing == <span class="hljs-number">0.0</span>:
            contours_spacing = (vmax-vmin)/<span class="hljs-number">5.0</span>
        
        cmap = cm.get_cmap(cmap)
        
        cmap.set_over(<span class="hljs-string">"white"</span>)
        cmap.set_under(<span class="hljs-string">"white"</span>)
        
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = self.cv3per[<span class="hljs-number">0</span>]
                cv3max = self.cv3per[<span class="hljs-number">1</span>] 
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
            X = np.linspace(cv1min, cv1max, self.res)
            plt.plot(X, self.fes)
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                plt.ylabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.ylabel(ylabel, size=label_size)
            
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">2</span>:
            fig = plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
            plt.imshow(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), cmap=cmap, interpolation=<span class="hljs-string">'nearest'</span>, 
                       extent=[cv1min, cv1max, cv2min, cv2max], 
                       aspect = (((cv1max-cv1min)/(cv2max-cv2min))/(aspect)),
                       vmin = vmin, vmax = vmax)
            cbar = plt.colorbar()
            cbar.set_label(energy_unit, size=label_size)
            <span class="hljs-keyword">if</span> contours:
                cont = plt.contour(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), 
                         levels = np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.01</span>), contours_spacing), 
                         extent=[cv1min, cv1max, cv2max, cv2min], 
                         colors = <span class="hljs-string">"k"</span>)
                plt.clabel(cont, levels = np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.01</span>), contours_spacing))
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                plt.ylabel(<span class="hljs-string">f'CV2 - <span class="hljs-subst">{self.cv2_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.ylabel(ylabel, size=label_size)
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                xlabel = <span class="hljs-string">"CV1 - "</span> + self.cv1_name
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                ylabel = <span class="hljs-string">"CV2 - "</span> + self.cv2_name
            <span class="hljs-keyword">if</span> zlabel == <span class="hljs-keyword">None</span>:
                zlabel = <span class="hljs-string">"CV3 - "</span> + self.cv3_name
            
            grid = pv.UniformGrid(
                dimensions=(self.res, self.res, self.res),
                spacing=((cv1max-cv1min)/self.res,(cv2max-cv2min)/self.res,(cv3max-cv3min)/self.res),
                origin=(cv1min, cv2min, cv3min)
            )
            grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
            <span class="hljs-keyword">if</span> levels == <span class="hljs-keyword">None</span>:
                contours = grid.contour(np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.01</span>), contours_spacing))
            <span class="hljs-keyword">else</span>:
                contours = grid.contour(levels)
            fescolors = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(contours.points.shape[<span class="hljs-number">0</span>]):
                fescolors.append(self.fes[int((contours.points[i,<span class="hljs-number">0</span>]-cv1min)*self.res/(cv1max-cv1min)),
                                          int((contours.points[i,<span class="hljs-number">1</span>]-cv2min)*self.res/(cv2max-cv2min)),
                                          int((contours.points[i,<span class="hljs-number">2</span>]-cv3min)*self.res/(cv3max-cv3min))])
            <span class="hljs-comment">#%% Visualization</span>
            pv.set_plot_theme(<span class="hljs-string">'document'</span>)
            p = pv.Plotter()
            p.add_mesh(contours, scalars=fescolors, opacity=opacity, cmap=cmap, show_scalar_bar=<span class="hljs-keyword">False</span>, interpolate_before_map=<span class="hljs-keyword">True</span>)
            p.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
            p.show()
            
        <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
            plt.savefig(png_name)
        
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_fes</span><span class="hljs-params">(self, fes)</span>:</span>
        self.fes = fes
        
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">surface_plot</span><span class="hljs-params">(self, cmap = <span class="hljs-string">"jet"</span>, 
                     energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, zlabel=None, 
                     label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">12</span>,<span class="hljs-number">7</span>], rstride=<span class="hljs-number">1</span>, cstride=<span class="hljs-number">1</span>, vmin = <span class="hljs-number">0</span>, vmax = None)</span>:</span>
        <span class="hljs-string">"""
        Function for visualization of 2D FES as 3D surface plot. For now, it is based on Matplotlib, but there are issues with interactivity. 
        
        It can be interacted with in jupyter notebook or jupyter lab in %matplotlib widget mode. Otherwise it is just static image of the 3D surface plot. 
        
        ```python
        %matplotlib widget
        fes.surface_plot()
        ```
        
        There are future plans to implement this function using the PyVista library.
        """</span>
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> self.cv1range==<span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>]
                    cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv1range = self.cv1max-self.cv1min
                    cv1min = self.cv1min
                    cv1max = self.cv1max
                    cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                    cv1max += cv1range*<span class="hljs-number">0.15</span>
                    cv1_fes_range = cv1max - cv1min
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1range[<span class="hljs-number">0</span>]
                cv1max = self.cv1range[<span class="hljs-number">1</span>]
                cv1_fes_range = cv1max-cv1min
            
            <span class="hljs-keyword">if</span> self.cv2range == <span class="hljs-keyword">None</span>:
                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>]
                    cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
                <span class="hljs-keyword">else</span>:
                    cv2range = self.cv2max-self.cv2min
                    cv2min = self.cv2min
                    cv2max = self.cv2max
                    cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                    cv2max += cv2range*<span class="hljs-number">0.15</span>
                    cv2_fes_range = cv2max - cv2min
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2range[<span class="hljs-number">0</span>]
                cv2max = self.cv2range[<span class="hljs-number">1</span>]
                cv2_fes_range = cv2max-cv2min
            
            x = np.linspace(cv1min, cv1max, self.res)
            y = np.linspace(cv2min, cv2max, self.res)
            
            X, Y = np.meshgrid(x, y)
            Z = self.fes
            
            <span class="hljs-comment">#grid = pv.StructuredGrid(X, Y, Z)</span>
            <span class="hljs-comment">#grid.plot()</span>
            
            fig = plt.figure()
            ax = plt.axes(projection=<span class="hljs-string">"3d"</span>)
            ax.plot_surface(X,Y,Z, cmap=cmap, rstride=rstride, cstride=cstride)
            
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                ax.set_xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                ax.set_xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                ax.set_ylabel(<span class="hljs-string">f'CV2 - <span class="hljs-subst">{self.cv2_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                ax.set_ylabel(ylabel, size=label_size)
            <span class="hljs-keyword">if</span> zlabel == <span class="hljs-keyword">None</span>:
                ax.set_zlabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                ax.set_zlabel(zlabel, size=label_size)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">f"Surface plot only works for FES with exactly two CVs, and this FES has <span class="hljs-subst">{self.cvs}</span>"</span>)
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeCV</span><span class="hljs-params">(self, CV=None, energy_unit=<span class="hljs-string">"kJ/mol"</span>, temp=<span class="hljs-number">300.0</span>)</span>:</span>
        <span class="hljs-string">"""
        This function is used to remove a CV from an existing FES. The function first recalculates the FES to an array of probabilities. The probabilities 
        are summed along the CV to be removed, and resulting probability distribution with 1 less dimension is converted back to FES. 
        
        Parameters:
        
        * CV = integer, the CV to be removed
        
        * energy_unit (default="kJ/mol") = has to be either "kJ/mol" or "kcal/mol". Make sure to suply the correct energy unit, otherwise you will get wrong FES as a result. 
        
        * temp (default=300.0) = temperature of the simulation in Kelvins.
        """</span>
        CV = int(float(CV))
        print(<span class="hljs-string">f"Removing CV <span class="hljs-subst">{CV}</span>."</span>)
        <span class="hljs-keyword">if</span> CV &gt; self.cvs:
            print(<span class="hljs-string">"Error: The CV to remove is not available in this FES object."</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            print(<span class="hljs-string">"Error: You can not remove the only CV. "</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> energy_unit == <span class="hljs-string">"kJ/mol"</span>:
                probabilities = np.exp(<span class="hljs-number">-1000</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">1</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>]]
                    new_fes.cv1min = self.cv2min
                    new_fes.cv1max = self.cv2max
                    new_fes.cv1_name = self.cv2_name
                    new_fes.cv1per = self.cv2per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">1</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv1per = self.cv1per
                <span class="hljs-keyword">return</span> new_fes
            <span class="hljs-keyword">elif</span> energy_unit == <span class="hljs-string">"kcal/mol"</span>:
                probabilities = np.exp(<span class="hljs-number">-1000</span>*<span class="hljs-number">4.184</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">1</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>]]
                    new_fes.cv1min = self.cv2min
                    new_fes.cv1max = self.cv2max
                    new_fes.cv1_name = self.cv2_name
                    new_fes.cv1per = self.cv2per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">1</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv1per = self.cv1per
                <span class="hljs-keyword">return</span> new_fes
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">"Error: unknown energy unit"</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> energy_unit == <span class="hljs-string">"kJ/mol"</span>:
                probabilities = np.exp(<span class="hljs-number">-1000</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>], self.periodic[<span class="hljs-number">2</span>]]
                    new_fes.cv1min = self.cv2min
                    new_fes.cv1max = self.cv2max
                    new_fes.cv2min = self.cv3min
                    new_fes.cv2max = self.cv3max
                    new_fes.cv1_name = self.cv2_name
                    new_fes.cv2_name = self.cv3_name
                    new_fes.cv1per = self.cv2per
                    new_fes.cv2per = self.cv3per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">2</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv2min = self.cv3min
                    new_fes.cv2max = self.cv3max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv2_name = self.cv3_name
                    new_fes.cv1per = self.cv1per
                    new_fes.cv2per = self.cv3per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">3</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">2</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">1</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv2min = self.cv2min
                    new_fes.cv2max = self.cv2max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv2_name = self.cv2_name
                    new_fes.cv1per = self.cv1per
                    new_fes.cv2per = self.cv2per
                <span class="hljs-keyword">return</span> new_fes
            <span class="hljs-keyword">elif</span> energy_unit == <span class="hljs-string">"kcal/mol"</span>:
                probabilities = np.exp(<span class="hljs-number">-1000</span>*<span class="hljs-number">4.184</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>], self.periodic[<span class="hljs-number">2</span>]]
                    new_fes.cv1min = self.cv2min
                    new_fes.cv1max = self.cv2max
                    new_fes.cv2min = self.cv3min
                    new_fes.cv2max = self.cv3max
                    new_fes.cv1_name = self.cv2_name
                    new_fes.cv2_name = self.cv3_name
                    new_fes.cv1per = self.cv2per
                    new_fes.cv2per = self.cv3per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">2</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv2min = self.cv3min
                    new_fes.cv2max = self.cv3max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv2_name = self.cv3_name
                    new_fes.cv1per = self.cv1per
                    new_fes.cv2per = self.cv3per
                <span class="hljs-keyword">if</span> CV == <span class="hljs-number">3</span>:
                    new_prob = np.sum(probabilities, axis=<span class="hljs-number">2</span>)
                    new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                    new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                    new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                    new_fes.cvs = <span class="hljs-number">2</span>
                    new_fes.res = self.res
                    new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">1</span>]]
                    new_fes.cv1min = self.cv1min
                    new_fes.cv1max = self.cv1max
                    new_fes.cv2min = self.cv2min
                    new_fes.cv2max = self.cv2max
                    new_fes.cv1_name = self.cv1_name
                    new_fes.cv2_name = self.cv2_name
                    new_fes.cv1per = self.cv1per
                    new_fes.cv2per = self.cv2per
                <span class="hljs-keyword">return</span> new_fes
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">"Error: unknown energy unit"</span>)
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_gif</span><span class="hljs-params">(self, gif_name=None, cmap = <span class="hljs-string">"jet"</span>, 
                 xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
                  opacity=<span class="hljs-number">0.2</span>, levels=None, frames=<span class="hljs-number">64</span>)</span>:</span>
        <span class="hljs-string">"""
        Function that generates animation of 3D FES showing different isosurfaces.
        
        ```python
        fes.make_gif(gif_name="FES.gif")
        ```
        
        Parameters:
        
        * gif_name (default="FES.gif") = String. Name of the gif of FES that will be saved in the current working directory.
        
        * cmap (default = "jet") = Matplotlib colormap used to color the 3D FES
        
        * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graph
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        * opacity (default = 0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
        
        * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
                If not provided, default values from contours parameters will be used instead. 
        
        * frames (default = 64) = Number of frames the animation will be made of. 
        """</span>
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                    cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                    cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                <span class="hljs-keyword">else</span>:
                    cv1min = self.cv1per[<span class="hljs-number">0</span>]
                    cv1max = self.cv1per[<span class="hljs-number">1</span>] 
            <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                    cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                    cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                <span class="hljs-keyword">else</span>:
                    cv2min = self.cv2per[<span class="hljs-number">0</span>]
                    cv2max = self.cv2per[<span class="hljs-number">1</span>] 
            <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                    cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                    cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                <span class="hljs-keyword">else</span>:
                    cv3min = self.cv3per[<span class="hljs-number">0</span>]
                    cv3max = self.cv3per[<span class="hljs-number">1</span>] 
            
            values = np.linspace(np.min(self.fes)+<span class="hljs-number">0.01</span>, np.max(self.fes), num=frames)
            grid = pv.UniformGrid(
                dimensions=(self.res, self.res, self.res),
                spacing=((cv1max-cv1min)/self.res,(cv2max-cv2min)/self.res,(cv3max-cv3min)/self.res),
                origin=(cv1min, cv2min, cv3min),
            )
            grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
            surface = grid.contour(values[:<span class="hljs-number">1</span>])
            surfaces = [grid.contour([v]) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]
            surface = surfaces[<span class="hljs-number">0</span>].copy()
            
            pv.set_plot_theme(<span class="hljs-string">'document'</span>)
            plotter = pv.Plotter(off_screen=<span class="hljs-keyword">True</span>)
            <span class="hljs-comment"># Open a movie file</span>
            plotter.open_gif(gif_name)

            <span class="hljs-comment"># Add initial mesh</span>
            plotter.add_mesh(
                surface,
                opacity=<span class="hljs-number">0.3</span>,
                clim=grid.get_data_range(),
                show_scalar_bar=<span class="hljs-keyword">False</span>,
                cmap=<span class="hljs-string">"jet"</span>
            )
            plotter.add_mesh(grid.outline_corners(), color=<span class="hljs-string">"k"</span>)
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> ylabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> zlabel == <span class="hljs-keyword">None</span>:
                plotter.show_grid(xlabel=<span class="hljs-string">f"CV1 - <span class="hljs-subst">{self.cv1_name}</span>"</span>, ylabel=<span class="hljs-string">f"CV2 - <span class="hljs-subst">{self.cv2_name}</span>"</span>, zlabel=<span class="hljs-string">f"CV3 - <span class="hljs-subst">{self.cv3_name}</span>"</span>)
            <span class="hljs-keyword">else</span>:
                plotter.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
            plotter.set_background(<span class="hljs-string">'white'</span>)
            plotter.show(auto_close=<span class="hljs-keyword">False</span>)

            <span class="hljs-comment"># Run through each frame</span>
            <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces:
                surface.copy_from(surf)
                plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>
            <span class="hljs-comment"># Run through backwards</span>
            <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces[::<span class="hljs-number">-1</span>]:
                surface.copy_from(surf)
                plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>

            <span class="hljs-comment"># Be sure to close the plotter when finished</span>
            plotter.close()
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Error: gif_plot is only available for FES with 3 CVs."</span>)     </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="metadynminer.Fes.make_gif"><code class="name flex">
<span>def <span class="ident">make_gif</span></span>(<span>self, gif_name=None, cmap='jet', xlabel=None, ylabel=None, zlabel=None, label_size=12, image_size=[10, 7], opacity=0.2, levels=None, frames=64)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that generates animation of 3D FES showing different isosurfaces.</p>
<pre><code class="language-python hljs">fes.make_gif(gif_name=<span class="hljs-string">"FES.gif"</span>)
</code></pre>
<p>Parameters:</p>
<ul>
<li>
<p>gif_name (default="FES.gif") = String. Name of the gif of FES that will be saved in the current working directory.</p>
</li>
<li>
<p>cmap (default = "jet") = Matplotlib colormap used to color the 3D FES</p>
</li>
<li>
<p>xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graph</p>
</li>
<li>
<p>labelsize (default = 12) = size of text in labels</p>
</li>
<li>
<p>image_size (default = [10,7]) = List of the width and height of the picture</p>
</li>
<li>
<p>opacity (default = 0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES</p>
</li>
<li>
<p>levels = Here you can specify list of free energy values for isosurfaces on 3D FES.
If not provided, default values from contours parameters will be used instead. </p>
</li>
<li>
<p>frames (default = 64) = Number of frames the animation will be made of.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_gif</span><span class="hljs-params">(self, gif_name=None, cmap = <span class="hljs-string">"jet"</span>, 
             xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
              opacity=<span class="hljs-number">0.2</span>, levels=None, frames=<span class="hljs-number">64</span>)</span>:</span>
    <span class="hljs-string">"""
    Function that generates animation of 3D FES showing different isosurfaces.
    
    ```python
    fes.make_gif(gif_name="FES.gif")
    ```
    
    Parameters:
    
    * gif_name (default="FES.gif") = String. Name of the gif of FES that will be saved in the current working directory.
    
    * cmap (default = "jet") = Matplotlib colormap used to color the 3D FES
    
    * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graph
    
    * labelsize (default = 12) = size of text in labels
    
    * image_size (default = [10,7]) = List of the width and height of the picture
    
    * opacity (default = 0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
    
    * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
            If not provided, default values from contours parameters will be used instead. 
    
    * frames (default = 64) = Number of frames the animation will be made of. 
    """</span>
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = self.cv3per[<span class="hljs-number">0</span>]
                cv3max = self.cv3per[<span class="hljs-number">1</span>] 
        
        values = np.linspace(np.min(self.fes)+<span class="hljs-number">0.01</span>, np.max(self.fes), num=frames)
        grid = pv.UniformGrid(
            dimensions=(self.res, self.res, self.res),
            spacing=((cv1max-cv1min)/self.res,(cv2max-cv2min)/self.res,(cv3max-cv3min)/self.res),
            origin=(cv1min, cv2min, cv3min),
        )
        grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
        surface = grid.contour(values[:<span class="hljs-number">1</span>])
        surfaces = [grid.contour([v]) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]
        surface = surfaces[<span class="hljs-number">0</span>].copy()
        
        pv.set_plot_theme(<span class="hljs-string">'document'</span>)
        plotter = pv.Plotter(off_screen=<span class="hljs-keyword">True</span>)
        <span class="hljs-comment"># Open a movie file</span>
        plotter.open_gif(gif_name)

        <span class="hljs-comment"># Add initial mesh</span>
        plotter.add_mesh(
            surface,
            opacity=<span class="hljs-number">0.3</span>,
            clim=grid.get_data_range(),
            show_scalar_bar=<span class="hljs-keyword">False</span>,
            cmap=<span class="hljs-string">"jet"</span>
        )
        plotter.add_mesh(grid.outline_corners(), color=<span class="hljs-string">"k"</span>)
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> ylabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> zlabel == <span class="hljs-keyword">None</span>:
            plotter.show_grid(xlabel=<span class="hljs-string">f"CV1 - <span class="hljs-subst">{self.cv1_name}</span>"</span>, ylabel=<span class="hljs-string">f"CV2 - <span class="hljs-subst">{self.cv2_name}</span>"</span>, zlabel=<span class="hljs-string">f"CV3 - <span class="hljs-subst">{self.cv3_name}</span>"</span>)
        <span class="hljs-keyword">else</span>:
            plotter.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
        plotter.set_background(<span class="hljs-string">'white'</span>)
        plotter.show(auto_close=<span class="hljs-keyword">False</span>)

        <span class="hljs-comment"># Run through each frame</span>
        <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces:
            surface.copy_from(surf)
            plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>
        <span class="hljs-comment"># Run through backwards</span>
        <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces[::<span class="hljs-number">-1</span>]:
            surface.copy_from(surf)
            plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>

        <span class="hljs-comment"># Be sure to close the plotter when finished</span>
        plotter.close()
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">"Error: gif_plot is only available for FES with 3 CVs."</span>)     </code></pre>
</details>
</dd>
<dt id="metadynminer.Fes.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, png_name=None, contours=True, contours_spacing=0.0, aspect=1.0, cmap='jet', energy_unit='kJ/mol', xlabel=None, ylabel=None, zlabel=None, label_size=12, image_size=[10, 7], vmin=0, vmax=None, opacity=0.2, levels=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to visualize FES, based on Matplotlib and PyVista. </p>
<pre><code class="language-python hljs">fes.plot(png_name=<span class="hljs-string">"fes.png"</span>)
</code></pre>
<p>Parameters:</p>
<ul>
<li>
<p>png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.</p>
</li>
<li>
<p>contours (default=True) = whether contours should be shown on 2D FES</p>
</li>
<li>
<p>contours_spacing (default=0.0) = when a positive number is set, it will be used as spacing for contours on 2D FES.
Otherwise, if contours=True, there will be five equally spaced contour levels.</p>
</li>
<li>
<p>aspect (default = 1.0) = aspect ratio of the graph. Works with 1D and 2D FES. </p>
</li>
<li>
<p>cmap (default = "jet") = Matplotlib colormap used to color 2D or 3D FES</p>
</li>
<li>
<p>energy_unit (default="kJ/mol") = String, used in description of colorbar</p>
</li>
<li>
<p>xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graphs</p>
</li>
<li>
<p>labelsize (default = 12) = size of text in labels</p>
</li>
<li>
<p>image_size (default = [10,7]) = List of the width and height of the picture</p>
</li>
<li>
<p>vmin (default=0) = real number, lower bound for the colormap on 2D FES</p>
</li>
<li>
<p>vmax = real number, upper bound for the colormap on 2D FES</p>
</li>
<li>
<p>opacity (default=0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES</p>
</li>
<li>
<p>levels = Here you can specify list of free energy values for isosurfaces on 3D FES.
If not provided, default values from contours parameters will be used instead.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span><span class="hljs-params">(self, png_name=None, contours=True, contours_spacing=<span class="hljs-number">0.0</span>, aspect = <span class="hljs-number">1.0</span>, cmap = <span class="hljs-string">"jet"</span>, 
             energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
             vmin = <span class="hljs-number">0</span>, vmax = None, opacity=<span class="hljs-number">0.2</span>, levels=None)</span>:</span>
    <span class="hljs-string">"""
    Function used to visualize FES, based on Matplotlib and PyVista. 
    
    ```python
    fes.plot(png_name="fes.png")
    ```
    
    Parameters:
    
    * png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.
    
    * contours (default=True) = whether contours should be shown on 2D FES
    
    * contours_spacing (default=0.0) = when a positive number is set, it will be used as spacing for contours on 2D FES. 
            Otherwise, if contours=True, there will be five equally spaced contour levels.
    
    * aspect (default = 1.0) = aspect ratio of the graph. Works with 1D and 2D FES. 
    
    * cmap (default = "jet") = Matplotlib colormap used to color 2D or 3D FES
    
    * energy_unit (default="kJ/mol") = String, used in description of colorbar
    
    * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graphs
    
    * labelsize (default = 12) = size of text in labels
    
    * image_size (default = [10,7]) = List of the width and height of the picture
    
    * vmin (default=0) = real number, lower bound for the colormap on 2D FES
    
    * vmax = real number, upper bound for the colormap on 2D FES
    
    * opacity (default=0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
    
    * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
                    If not provided, default values from contours parameters will be used instead. 
    """</span>
    <span class="hljs-keyword">if</span> vmax == <span class="hljs-keyword">None</span>:
        vmax = np.max(self.fes)+<span class="hljs-number">0.01</span> <span class="hljs-comment"># if the addition is smaller than 0.01, the 3d plot stops working. </span>
        
    <span class="hljs-keyword">if</span> contours_spacing == <span class="hljs-number">0.0</span>:
        contours_spacing = (vmax-vmin)/<span class="hljs-number">5.0</span>
    
    cmap = cm.get_cmap(cmap)
    
    cmap.set_over(<span class="hljs-string">"white"</span>)
    cmap.set_under(<span class="hljs-string">"white"</span>)
    
    <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
            cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
        <span class="hljs-keyword">else</span>:
            cv1min = self.cv1per[<span class="hljs-number">0</span>]
            cv1max = self.cv1per[<span class="hljs-number">1</span>] 
    <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
            cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
        <span class="hljs-keyword">else</span>:
            cv2min = self.cv2per[<span class="hljs-number">0</span>]
            cv2max = self.cv2per[<span class="hljs-number">1</span>] 
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
            cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
        <span class="hljs-keyword">else</span>:
            cv3min = self.cv3per[<span class="hljs-number">0</span>]
            cv3max = self.cv3per[<span class="hljs-number">1</span>] 
    
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
        plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
        X = np.linspace(cv1min, cv1max, self.res)
        plt.plot(X, self.fes)
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.xlabel(xlabel, size=label_size)
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            plt.ylabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.ylabel(ylabel, size=label_size)
        
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">2</span>:
        fig = plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
        plt.imshow(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), cmap=cmap, interpolation=<span class="hljs-string">'nearest'</span>, 
                   extent=[cv1min, cv1max, cv2min, cv2max], 
                   aspect = (((cv1max-cv1min)/(cv2max-cv2min))/(aspect)),
                   vmin = vmin, vmax = vmax)
        cbar = plt.colorbar()
        cbar.set_label(energy_unit, size=label_size)
        <span class="hljs-keyword">if</span> contours:
            cont = plt.contour(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), 
                     levels = np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.01</span>), contours_spacing), 
                     extent=[cv1min, cv1max, cv2max, cv2min], 
                     colors = <span class="hljs-string">"k"</span>)
            plt.clabel(cont, levels = np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.01</span>), contours_spacing))
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.xlabel(xlabel, size=label_size)
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            plt.ylabel(<span class="hljs-string">f'CV2 - <span class="hljs-subst">{self.cv2_name}</span>'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.ylabel(ylabel, size=label_size)
    
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            xlabel = <span class="hljs-string">"CV1 - "</span> + self.cv1_name
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            ylabel = <span class="hljs-string">"CV2 - "</span> + self.cv2_name
        <span class="hljs-keyword">if</span> zlabel == <span class="hljs-keyword">None</span>:
            zlabel = <span class="hljs-string">"CV3 - "</span> + self.cv3_name
        
        grid = pv.UniformGrid(
            dimensions=(self.res, self.res, self.res),
            spacing=((cv1max-cv1min)/self.res,(cv2max-cv2min)/self.res,(cv3max-cv3min)/self.res),
            origin=(cv1min, cv2min, cv3min)
        )
        grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
        <span class="hljs-keyword">if</span> levels == <span class="hljs-keyword">None</span>:
            contours = grid.contour(np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.01</span>), contours_spacing))
        <span class="hljs-keyword">else</span>:
            contours = grid.contour(levels)
        fescolors = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(contours.points.shape[<span class="hljs-number">0</span>]):
            fescolors.append(self.fes[int((contours.points[i,<span class="hljs-number">0</span>]-cv1min)*self.res/(cv1max-cv1min)),
                                      int((contours.points[i,<span class="hljs-number">1</span>]-cv2min)*self.res/(cv2max-cv2min)),
                                      int((contours.points[i,<span class="hljs-number">2</span>]-cv3min)*self.res/(cv3max-cv3min))])
        <span class="hljs-comment">#%% Visualization</span>
        pv.set_plot_theme(<span class="hljs-string">'document'</span>)
        p = pv.Plotter()
        p.add_mesh(contours, scalars=fescolors, opacity=opacity, cmap=cmap, show_scalar_bar=<span class="hljs-keyword">False</span>, interpolate_before_map=<span class="hljs-keyword">True</span>)
        p.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
        p.show()
        
    <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
        plt.savefig(png_name)</code></pre>
</details>
</dd>
<dt id="metadynminer.Fes.removeCV"><code class="name flex">
<span>def <span class="ident">removeCV</span></span>(<span>self, CV=None, energy_unit='kJ/mol', temp=300.0)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to remove a CV from an existing FES. The function first recalculates the FES to an array of probabilities. The probabilities
are summed along the CV to be removed, and resulting probability distribution with 1 less dimension is converted back to FES. </p>
<p>Parameters:</p>
<ul>
<li>
<p>CV = integer, the CV to be removed</p>
</li>
<li>
<p>energy_unit (default="kJ/mol") = has to be either "kJ/mol" or "kcal/mol". Make sure to suply the correct energy unit, otherwise you will get wrong FES as a result. </p>
</li>
<li>
<p>temp (default=300.0) = temperature of the simulation in Kelvins.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeCV</span><span class="hljs-params">(self, CV=None, energy_unit=<span class="hljs-string">"kJ/mol"</span>, temp=<span class="hljs-number">300.0</span>)</span>:</span>
    <span class="hljs-string">"""
    This function is used to remove a CV from an existing FES. The function first recalculates the FES to an array of probabilities. The probabilities 
    are summed along the CV to be removed, and resulting probability distribution with 1 less dimension is converted back to FES. 
    
    Parameters:
    
    * CV = integer, the CV to be removed
    
    * energy_unit (default="kJ/mol") = has to be either "kJ/mol" or "kcal/mol". Make sure to suply the correct energy unit, otherwise you will get wrong FES as a result. 
    
    * temp (default=300.0) = temperature of the simulation in Kelvins.
    """</span>
    CV = int(float(CV))
    print(<span class="hljs-string">f"Removing CV <span class="hljs-subst">{CV}</span>."</span>)
    <span class="hljs-keyword">if</span> CV &gt; self.cvs:
        print(<span class="hljs-string">"Error: The CV to remove is not available in this FES object."</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
        print(<span class="hljs-string">"Error: You can not remove the only CV. "</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
        <span class="hljs-keyword">if</span> energy_unit == <span class="hljs-string">"kJ/mol"</span>:
            probabilities = np.exp(<span class="hljs-number">-1000</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">1</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>]]
                new_fes.cv1min = self.cv2min
                new_fes.cv1max = self.cv2max
                new_fes.cv1_name = self.cv2_name
                new_fes.cv1per = self.cv2per
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">1</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>]]
                new_fes.cv1min = self.cv1min
                new_fes.cv1max = self.cv1max
                new_fes.cv1_name = self.cv1_name
                new_fes.cv1per = self.cv1per
            <span class="hljs-keyword">return</span> new_fes
        <span class="hljs-keyword">elif</span> energy_unit == <span class="hljs-string">"kcal/mol"</span>:
            probabilities = np.exp(<span class="hljs-number">-1000</span>*<span class="hljs-number">4.184</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">1</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>]]
                new_fes.cv1min = self.cv2min
                new_fes.cv1max = self.cv2max
                new_fes.cv1_name = self.cv2_name
                new_fes.cv1per = self.cv2per
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">1</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>]]
                new_fes.cv1min = self.cv1min
                new_fes.cv1max = self.cv1max
                new_fes.cv1_name = self.cv1_name
                new_fes.cv1per = self.cv1per
            <span class="hljs-keyword">return</span> new_fes
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Error: unknown energy unit"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">if</span> energy_unit == <span class="hljs-string">"kJ/mol"</span>:
            probabilities = np.exp(<span class="hljs-number">-1000</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">2</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>], self.periodic[<span class="hljs-number">2</span>]]
                new_fes.cv1min = self.cv2min
                new_fes.cv1max = self.cv2max
                new_fes.cv2min = self.cv3min
                new_fes.cv2max = self.cv3max
                new_fes.cv1_name = self.cv2_name
                new_fes.cv2_name = self.cv3_name
                new_fes.cv1per = self.cv2per
                new_fes.cv2per = self.cv3per
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">2</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">2</span>]]
                new_fes.cv1min = self.cv1min
                new_fes.cv1max = self.cv1max
                new_fes.cv2min = self.cv3min
                new_fes.cv2max = self.cv3max
                new_fes.cv1_name = self.cv1_name
                new_fes.cv2_name = self.cv3_name
                new_fes.cv1per = self.cv1per
                new_fes.cv2per = self.cv3per
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">3</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">2</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">2</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">1</span>]]
                new_fes.cv1min = self.cv1min
                new_fes.cv1max = self.cv1max
                new_fes.cv2min = self.cv2min
                new_fes.cv2max = self.cv2max
                new_fes.cv1_name = self.cv1_name
                new_fes.cv2_name = self.cv2_name
                new_fes.cv1per = self.cv1per
                new_fes.cv2per = self.cv2per
            <span class="hljs-keyword">return</span> new_fes
        <span class="hljs-keyword">elif</span> energy_unit == <span class="hljs-string">"kcal/mol"</span>:
            probabilities = np.exp(<span class="hljs-number">-1000</span>*<span class="hljs-number">4.184</span>*self.fes/<span class="hljs-number">8.314</span>/temp)
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">1</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">0</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">2</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">1</span>], self.periodic[<span class="hljs-number">2</span>]]
                new_fes.cv1min = self.cv2min
                new_fes.cv1max = self.cv2max
                new_fes.cv2min = self.cv3min
                new_fes.cv2max = self.cv3max
                new_fes.cv1_name = self.cv2_name
                new_fes.cv2_name = self.cv3_name
                new_fes.cv1per = self.cv2per
                new_fes.cv2per = self.cv3per
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">2</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">1</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">2</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">2</span>]]
                new_fes.cv1min = self.cv1min
                new_fes.cv1max = self.cv1max
                new_fes.cv2min = self.cv3min
                new_fes.cv2max = self.cv3max
                new_fes.cv1_name = self.cv1_name
                new_fes.cv2_name = self.cv3_name
                new_fes.cv1per = self.cv1per
                new_fes.cv2per = self.cv3per
            <span class="hljs-keyword">if</span> CV == <span class="hljs-number">3</span>:
                new_prob = np.sum(probabilities, axis=<span class="hljs-number">2</span>)
                new_fes = Fes(hills=<span class="hljs-keyword">None</span>)
                new_fes.fes = <span class="hljs-number">-8.314</span>*temp*np.log(new_prob)/<span class="hljs-number">1000</span>/<span class="hljs-number">4.184</span>
                new_fes.fes = new_fes.fes - np.min(new_fes.fes)
                new_fes.cvs = <span class="hljs-number">2</span>
                new_fes.res = self.res
                new_fes.periodic = [self.periodic[<span class="hljs-number">0</span>], self.periodic[<span class="hljs-number">1</span>]]
                new_fes.cv1min = self.cv1min
                new_fes.cv1max = self.cv1max
                new_fes.cv2min = self.cv2min
                new_fes.cv2max = self.cv2max
                new_fes.cv1_name = self.cv1_name
                new_fes.cv2_name = self.cv2_name
                new_fes.cv1per = self.cv1per
                new_fes.cv2per = self.cv2per
            <span class="hljs-keyword">return</span> new_fes
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Error: unknown energy unit"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span></code></pre>
</details>
</dd>
<dt id="metadynminer.Fes.surface_plot"><code class="name flex">
<span>def <span class="ident">surface_plot</span></span>(<span>self, cmap='jet', energy_unit='kJ/mol', xlabel=None, ylabel=None, zlabel=None, label_size=12, image_size=[12, 7], rstride=1, cstride=1, vmin=0, vmax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Function for visualization of 2D FES as 3D surface plot. For now, it is based on Matplotlib, but there are issues with interactivity. </p>
<p>It can be interacted with in jupyter notebook or jupyter lab in %matplotlib widget mode. Otherwise it is just static image of the 3D surface plot. </p>
<pre><code class="language-python hljs">%matplotlib widget
fes.surface_plot()
</code></pre>
<p>There are future plans to implement this function using the PyVista library.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">surface_plot</span><span class="hljs-params">(self, cmap = <span class="hljs-string">"jet"</span>, 
                 energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, zlabel=None, 
                 label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">12</span>,<span class="hljs-number">7</span>], rstride=<span class="hljs-number">1</span>, cstride=<span class="hljs-number">1</span>, vmin = <span class="hljs-number">0</span>, vmax = None)</span>:</span>
    <span class="hljs-string">"""
    Function for visualization of 2D FES as 3D surface plot. For now, it is based on Matplotlib, but there are issues with interactivity. 
    
    It can be interacted with in jupyter notebook or jupyter lab in %matplotlib widget mode. Otherwise it is just static image of the 3D surface plot. 
    
    ```python
    %matplotlib widget
    fes.surface_plot()
    ```
    
    There are future plans to implement this function using the PyVista library.
    """</span>
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">2</span>:
        <span class="hljs-keyword">if</span> self.cv1range==<span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>]
                cv1_fes_range = np.abs(self.cv1per[<span class="hljs-number">1</span>]-self.cv1per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv1range = self.cv1max-self.cv1min
                cv1min = self.cv1min
                cv1max = self.cv1max
                cv1min -= cv1range*<span class="hljs-number">0.15</span>          
                cv1max += cv1range*<span class="hljs-number">0.15</span>
                cv1_fes_range = cv1max - cv1min
        <span class="hljs-keyword">else</span>:
            cv1min = self.cv1range[<span class="hljs-number">0</span>]
            cv1max = self.cv1range[<span class="hljs-number">1</span>]
            cv1_fes_range = cv1max-cv1min
        
        <span class="hljs-keyword">if</span> self.cv2range == <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>]
                cv2_fes_range = np.abs(self.cv2per[<span class="hljs-number">1</span>]-self.cv2per[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">else</span>:
                cv2range = self.cv2max-self.cv2min
                cv2min = self.cv2min
                cv2max = self.cv2max
                cv2min -= cv2range*<span class="hljs-number">0.15</span>          
                cv2max += cv2range*<span class="hljs-number">0.15</span>
                cv2_fes_range = cv2max - cv2min
        <span class="hljs-keyword">else</span>:
            cv2min = self.cv2range[<span class="hljs-number">0</span>]
            cv2max = self.cv2range[<span class="hljs-number">1</span>]
            cv2_fes_range = cv2max-cv2min
        
        x = np.linspace(cv1min, cv1max, self.res)
        y = np.linspace(cv2min, cv2max, self.res)
        
        X, Y = np.meshgrid(x, y)
        Z = self.fes
        
        <span class="hljs-comment">#grid = pv.StructuredGrid(X, Y, Z)</span>
        <span class="hljs-comment">#grid.plot()</span>
        
        fig = plt.figure()
        ax = plt.axes(projection=<span class="hljs-string">"3d"</span>)
        ax.plot_surface(X,Y,Z, cmap=cmap, rstride=rstride, cstride=cstride)
        
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            ax.set_xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            ax.set_xlabel(xlabel, size=label_size)
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            ax.set_ylabel(<span class="hljs-string">f'CV2 - <span class="hljs-subst">{self.cv2_name}</span>'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            ax.set_ylabel(ylabel, size=label_size)
        <span class="hljs-keyword">if</span> zlabel == <span class="hljs-keyword">None</span>:
            ax.set_zlabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            ax.set_zlabel(zlabel, size=label_size)
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">f"Surface plot only works for FES with exactly two CVs, and this FES has <span class="hljs-subst">{self.cvs}</span>"</span>)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="metadynminer.Hills"><code class="flex name class">
<span>class <span class="ident">Hills</span></span>
<span>(</span><span>name='HILLS', encoding='utf8', ignoretime=True, periodic=[False, False], cv1per=[-3.141592653589793, 3.141592653589793], cv2per=[-3.141592653589793, 3.141592653589793], cv3per=[-3.141592653589793, 3.141592653589793], timestep=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object of Hills class are created for loading HILLS files, and obtaining the necessary information from them. </p>
<p>Hills files are loaded with command:</p>
<pre><code class="language-python hljs">hillsfile = metadynminer.Hills(name=<span class="hljs-string">"HILLS"</span>, periodic=[<span class="hljs-keyword">False</span>,<span class="hljs-keyword">False</span>])
</code></pre>
<p>optional parameters:</p>
<ul>
<li>
<p>name (default="HILLS") = string with name of HILLS file</p>
</li>
<li>
<p>ignoretime (default=True) = boolean, if set to False, it will save the time in the HILLS file;
if set to True, and timestep is not set,
each time value will be incremented by the same amount as the time of the first step.</p>
</li>
<li>
<p>timestep = numeric value of the time difference between hills, in picoseconds</p>
</li>
<li>
<p>periodic (default=[False, False]) = list of boolean values telling which CV is periodic.</p>
</li>
<li>
<p>cv1per, cv2per, cv3per (defaults = [-numpy.pi, numpy.pi]) = List of two numeric values defining the periodicity of given CV.
Has to be provided for each periodic CV.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hills</span>:</span>
    <span class="hljs-string">"""
    Object of Hills class are created for loading HILLS files, and obtaining the necessary information from them. 

    Hills files are loaded with command:
    ```python
    hillsfile = metadynminer.Hills(name="HILLS", periodic=[False,False])
    ```
    
    optional parameters:
    
    * name (default="HILLS") = string with name of HILLS file
    
    * ignoretime (default=True) = boolean, if set to False, it will save the time in the HILLS file;
                                if set to True, and timestep is not set, 
                                        each time value will be incremented by the same amount as the time of the first step.
                                        
    * timestep = numeric value of the time difference between hills, in picoseconds
    
    * periodic (default=[False, False]) = list of boolean values telling which CV is periodic.
    
    * cv1per, cv2per, cv3per (defaults = [-numpy.pi, numpy.pi]) = List of two numeric values defining the periodicity of given CV. 
                                        Has to be provided for each periodic CV.
    """</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, name=<span class="hljs-string">"HILLS"</span>, encoding=<span class="hljs-string">"utf8"</span>, ignoretime=True, periodic=[False, False], 
                 cv1per=[-np.pi, np.pi],cv2per=[-np.pi, np.pi],cv3per=[-np.pi, np.pi], timestep=None)</span>:</span>
        self.read(name, encoding, ignoretime, periodic, 
                 cv1per=[-np.pi, np.pi],cv2per=[-np.pi, np.pi],cv3per=[-np.pi, np.pi], timestep=timestep)
        self.hillsfilename = name
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read</span><span class="hljs-params">(self, name=<span class="hljs-string">"HILLS"</span>, encoding=<span class="hljs-string">"utf8"</span>, ignoretime=True, periodic=None, 
                 cv1per=[-np.pi, np.pi],cv2per=[-np.pi, np.pi],cv3per=[-np.pi, np.pi], timestep=None)</span>:</span>
        <span class="hljs-keyword">with</span> open(name, <span class="hljs-string">'r'</span>, encoding=encoding) <span class="hljs-keyword">as</span> hillsfile:
            lines = hillsfile.readlines()
        columns = lines[<span class="hljs-number">0</span>].split() 
        number_of_columns_head = len(columns) - <span class="hljs-number">2</span>
        
        <span class="hljs-keyword">if</span> number_of_columns_head == <span class="hljs-number">5</span>:
            self.cvs = <span class="hljs-number">1</span>
            self.cv1_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">3</span>]
            <span class="hljs-keyword">if</span> periodic == <span class="hljs-keyword">None</span>:
                periodic = list(<span class="hljs-keyword">False</span>)
            
            self.periodic = list(periodic[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>])
            self.cv1per = cv1per

        <span class="hljs-keyword">elif</span> number_of_columns_head == <span class="hljs-number">7</span>:
            self.cvs = <span class="hljs-number">2</span>
            self.cv1_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">3</span>]
            self.cv2_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">4</span>]
            <span class="hljs-keyword">if</span> len(periodic) == <span class="hljs-number">2</span>:
                self.periodic = periodic[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]
                self.cv1per = cv1per
                self.cv2per = cv2per
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">f"Error: argument 'periodic' has wrong number of parameters(<span class="hljs-subst">{len(periodic)}</span>)"</span>)
        <span class="hljs-keyword">elif</span> number_of_columns_head == <span class="hljs-number">9</span>:
            self.cvs = <span class="hljs-number">3</span>
            self.cv1_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">3</span>]
            self.cv2_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">4</span>]
            self.cv3_name = lines[<span class="hljs-number">0</span>].split()[<span class="hljs-number">5</span>]
            
            <span class="hljs-keyword">if</span> len(periodic) == <span class="hljs-number">3</span>:
                self.periodic = periodic[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]
                self.cv1per = cv1per
                self.cv2per = cv2per
                self.cv3per = cv3per
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">f"Argument 'periodic' has wrong number of parameters(<span class="hljs-subst">{len(periodic)}</span>)"</span>)
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Unexpected number of columns in provided HILLS file."</span>)
        
        
        <span class="hljs-keyword">if</span> ignoretime:
            <span class="hljs-keyword">if</span> timestep != <span class="hljs-keyword">None</span>:
                dt = timestep
            <span class="hljs-keyword">else</span>:
                <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(lines)):
                    <span class="hljs-keyword">if</span> lines[line][<span class="hljs-number">0</span>] != <span class="hljs-string">"#"</span>:
                        dt = round(float(lines[line].split()[<span class="hljs-number">0</span>]),<span class="hljs-number">14</span>)
                        <span class="hljs-keyword">break</span>
        t = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> range(len(lines)):
            <span class="hljs-keyword">if</span> lines[line][<span class="hljs-number">0</span>] != <span class="hljs-string">"#"</span>:
                t += <span class="hljs-number">1</span> 
                <span class="hljs-keyword">if</span> t == <span class="hljs-number">1</span>:
                    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
                        self.sigma1 = float(lines[line].split()[<span class="hljs-number">2</span>])
                        self.biasf = float(lines[line].split()[<span class="hljs-number">4</span>])
                    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
                        self.sigma1 = float(lines[line].split()[<span class="hljs-number">3</span>])
                        self.sigma2 = float(lines[line].split()[<span class="hljs-number">4</span>])
                        self.biasf = float(lines[line].split()[<span class="hljs-number">6</span>])
                    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
                        self.sigma1 = float(lines[line].split()[<span class="hljs-number">4</span>])
                        self.sigma2 = float(lines[line].split()[<span class="hljs-number">5</span>])
                        self.sigma3 = float(lines[line].split()[<span class="hljs-number">6</span>])
                        self.biasf = float(lines[line].split()[<span class="hljs-number">8</span>])
                    self.hills = [lines[line].split()]
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> len(lines[line].split()) == <span class="hljs-number">5</span>:
                        self.hills.append(lines[line].split())
                        <span class="hljs-keyword">if</span> ignoretime:
                            self.hills[t<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] = t*dt
                    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> len(lines[line].split()) == <span class="hljs-number">7</span>:
                        self.hills.append(lines[line].split())
                        <span class="hljs-keyword">if</span> ignoretime:
                            self.hills[t<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] = t*dt
                    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> len(lines[line].split()) == <span class="hljs-number">9</span>:
                        self.hills.append(lines[line].split())
                        <span class="hljs-keyword">if</span> ignoretime:
                            self.hills[t<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] = t*dt
                    
        
        self.hills = np.array(self.hills, dtype=np.double)
                
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            self.cv1 = self.hills[:,<span class="hljs-number">1</span>]
            self.sigma1 = self.hills[:,<span class="hljs-number">2</span>]
            self.heights = self.hills[:,<span class="hljs-number">3</span>]
            self.biasf = self.hills[:,<span class="hljs-number">4</span>]
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            self.cv1 = self.hills[:,<span class="hljs-number">1</span>]
            self.cv2 = self.hills[:,<span class="hljs-number">2</span>]
            self.sigma1 = self.hills[:,<span class="hljs-number">3</span>]
            self.sigma2 = self.hills[:,<span class="hljs-number">4</span>]
            self.heights = self.hills[:,<span class="hljs-number">5</span>]
            self.biasf = self.hills[:,<span class="hljs-number">6</span>]
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            self.cv1 = self.hills[:,<span class="hljs-number">1</span>]
            self.cv2 = self.hills[:,<span class="hljs-number">2</span>]
            self.cv3 = self.hills[:,<span class="hljs-number">3</span>]
            self.sigma1 = self.hills[:,<span class="hljs-number">4</span>]
            self.sigma2 = self.hills[:,<span class="hljs-number">5</span>]
            self.sigma3 = self.hills[:,<span class="hljs-number">6</span>]
            self.heights = self.hills[:,<span class="hljs-number">7</span>]
            self.biasf = self.hills[:,<span class="hljs-number">8</span>]
        <span class="hljs-keyword">return</span> self
    
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv1</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv1
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv2</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv2
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv3</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv3
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv1per</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv1per
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv2per</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv2per
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv3per</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv3per
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_periodic</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.periodic
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv1_name</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv1_name
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv2_name</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv2_name
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cv3_name</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cv3_name
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_hills</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.hills
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_number_of_cvs</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.cvs
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sigma1</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.sigma1
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sigma2</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.sigma2
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sigma3</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span> self.sigma3
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_heights</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-keyword">return</span>(self.heights)
    
    __pdoc__[<span class="hljs-string">"Hills.get_cv1"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv2"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv3"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv1per"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv2per"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv3per"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv1_name"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv2_name"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_cv3_name"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_periodic"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_hills"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_number_of_cvs"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_sigma1"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_sigma2"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_sigma3"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.get_heights"</span>] = <span class="hljs-keyword">False</span>
    __pdoc__[<span class="hljs-string">"Hills.read"</span>] = <span class="hljs-keyword">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_heights</span><span class="hljs-params">(self, png_name=None, energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>])</span>:</span>
        <span class="hljs-string">"""
        Function used to visualize heights of the hills that were added during the simulation. 
        
        ```python
        hillsfile.plot_heights(png_name="picture.png")
        ```
        
        Parameters:
        
        * png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.
        
        * energy_unit (default="kJ/mol") = String, used in description of the y axis
        
        * xlabel, ylabel = Strings, if provided, they will be used as labels for the graphs
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        """</span>
        plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
        plt.plot(range(len(self.heights)), self.heights)
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            plt.xlabel(<span class="hljs-string">f'time (ps)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.xlabel(xlabel, size=label_size)
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            plt.ylabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.ylabel(ylabel, size=label_size)
            
        <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
            plt.savefig(png_name)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="metadynminer.Hills.plot_heights"><code class="name flex">
<span>def <span class="ident">plot_heights</span></span>(<span>self, png_name=None, energy_unit='kJ/mol', xlabel=None, ylabel=None, label_size=12, image_size=[10, 7])</span>
</code></dt>
<dd>
<div class="desc"><p>Function used to visualize heights of the hills that were added during the simulation. </p>
<pre><code class="language-python hljs">hillsfile.plot_heights(png_name=<span class="hljs-string">"picture.png"</span>)
</code></pre>
<p>Parameters:</p>
<ul>
<li>
<p>png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.</p>
</li>
<li>
<p>energy_unit (default="kJ/mol") = String, used in description of the y axis</p>
</li>
<li>
<p>xlabel, ylabel = Strings, if provided, they will be used as labels for the graphs</p>
</li>
<li>
<p>labelsize (default = 12) = size of text in labels</p>
</li>
<li>
<p>image_size (default = [10,7]) = List of the width and height of the picture</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_heights</span><span class="hljs-params">(self, png_name=None, energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>])</span>:</span>
    <span class="hljs-string">"""
    Function used to visualize heights of the hills that were added during the simulation. 
    
    ```python
    hillsfile.plot_heights(png_name="picture.png")
    ```
    
    Parameters:
    
    * png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.
    
    * energy_unit (default="kJ/mol") = String, used in description of the y axis
    
    * xlabel, ylabel = Strings, if provided, they will be used as labels for the graphs
    
    * labelsize (default = 12) = size of text in labels
    
    * image_size (default = [10,7]) = List of the width and height of the picture
    
    """</span>
    plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
    plt.plot(range(len(self.heights)), self.heights)
    <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
        plt.xlabel(<span class="hljs-string">f'time (ps)'</span>, size=label_size)
    <span class="hljs-keyword">else</span>:
        plt.xlabel(xlabel, size=label_size)
    <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
        plt.ylabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
    <span class="hljs-keyword">else</span>:
        plt.ylabel(ylabel, size=label_size)
        
    <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
        plt.savefig(png_name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="metadynminer.Minima"><code class="flex name class">
<span>class <span class="ident">Minima</span></span>
<span>(</span><span>fes, nbins=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Object of Minima class is created to find local free energy minima on FES.
The FES is first divided to some number of bins,
(the number of bins can be set with option nbins, default is 8)
and the absolute minima is found for each bin. Then the algorithm checks
if this point is really a local minimum by comparing to the surrounding points of FES.</p>
<p>The list of minima is stored as pandas dataframe. </p>
<p>Command:</p>
<pre><code class="language-python hljs">minima = metadynminer.Minima(fes=f, nbins=<span class="hljs-number">8</span>)
</code></pre>
<p>List of minima can be later called like this:</p>
<pre><code class="language-python hljs">print(minima.minima)
</code></pre>
<p>Parameters:</p>
<ul>
<li>
<p>fes = Fes object to find the minima on</p>
</li>
<li>
<p>nbins (default = 8) = number of bins to divide the FES</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Minima</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-string">"""
    Object of Minima class is created to find local free energy minima on FES. 
    The FES is first divided to some number of bins, 
    (the number of bins can be set with option nbins, default is 8)
    and the absolute minima is found for each bin. Then the algorithm checks 
    if this point is really a local minimum by comparing to the surrounding points of FES.
    
    The list of minima is stored as pandas dataframe. 
    
    Command:
    ```python
    minima = metadynminer.Minima(fes=f, nbins=8)
    ```
    
    List of minima can be later called like this:
    
    ```python
    print(minima.minima)
    ```
    
    Parameters:
    
    * fes = Fes object to find the minima on
    
    * nbins (default = 8) = number of bins to divide the FES
    """</span>
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, fes, nbins = <span class="hljs-number">8</span>)</span>:</span>
        self.fes = fes.fes
        self.periodic = fes.periodic
        self.cvs = fes.cvs
        self.res = fes.res

        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            self.cv1_name = fes.cv1_name
            self.cv1min = fes.cv1min
            self.cv1max = fes.cv1max
            self.cv1per = fes.cv1per
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">2</span>:
            self.cv2min = fes.cv2min
            self.cv2max = fes.cv2max
            self.cv2_name = fes.cv2_name
            self.cv2per = fes.cv2per
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            self.cv3min = fes.cv3min
            self.cv3max = fes.cv3max
            self.cv3_name = fes.cv3_name
            self.cv3per = fes.cv3per
        
        self.findminima(nbins=nbins)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findminima</span><span class="hljs-params">(self, nbins=<span class="hljs-number">8</span>)</span>:</span>
        <span class="hljs-string">"""
        Internal method for finding local minima on FES.
        """</span>
        <span class="hljs-keyword">if</span> int(nbins) != nbins:
            nbins = int(nbins)
            print(<span class="hljs-string">f"Number of bins must be an integer, it will be set to <span class="hljs-subst">{nbins}</span>."</span>)
        <span class="hljs-keyword">if</span> self.res%nbins != <span class="hljs-number">0</span>:
            print(<span class="hljs-string">"Error: Resolution of FES must be divisible by number of bins."</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">if</span> nbins &gt; self.res/<span class="hljs-number">2</span>:
            print(<span class="hljs-string">"Error: Number of bins is too high."</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        bin_size = int(self.res/nbins)

        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1min
                cv1max = self.cv1max 
        <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2min
                cv2max = self.cv2max 
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = self.cv3min
                cv3max = self.cv3max

        self.minima = []
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">for</span> bin1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                fes_slice = self.fes[bin1*bin_size:(bin1+<span class="hljs-number">1</span>)*bin_size]
                bin_min = np.min(fes_slice)
                argmin = np.argmin(fes_slice)
                <span class="hljs-comment"># indexes of global minimum of a bin</span>
                bin_min_arg_cv1 = int(argmin%bin_size)
                <span class="hljs-comment"># indexes of that minima in the original fes (indexes +1)</span>
                min_cv1_b = int(bin_min_arg_cv1+bin1*bin_size)
                <span class="hljs-keyword">if</span> (bin_min_arg_cv1 &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg_cv1&lt;(bin_size<span class="hljs-number">-1</span>)):
                    min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                    <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                        self.minima = np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])
                    <span class="hljs-keyword">else</span>:
                        self.minima = np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])))
                <span class="hljs-keyword">else</span>:
                    around = []
                    min_cv1_b_low = min_cv1_b - <span class="hljs-number">1</span>
                    <span class="hljs-keyword">if</span> min_cv1_b_low == <span class="hljs-number">-1</span>:
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                            min_cv1_b_low = self.res - <span class="hljs-number">1</span>
                        <span class="hljs-keyword">else</span>:
                            min_cv1_b_low = float(<span class="hljs-string">"nan"</span>)

                    min_cv1_b_high = min_cv1_b + <span class="hljs-number">1</span>
                    <span class="hljs-keyword">if</span> min_cv1_b_high == self.res:
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                            min_cv1_b_high = <span class="hljs-number">0</span>
                        <span class="hljs-keyword">else</span>:
                            min_cv1_b_high = float(<span class="hljs-string">"nan"</span>)

                    <span class="hljs-comment">#1_b_low</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                        around.append(self.fes[min_cv1_b_low])
                    <span class="hljs-comment">#1_b_high</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                        around.append(self.fes[min_cv1_b_high])
                    
                    <span class="hljs-keyword">if</span> bin_min &lt; np.min(around):
                        min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                        <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                            self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])
                        <span class="hljs-keyword">else</span>:
                            self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])))
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">for</span> bin1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                <span class="hljs-keyword">for</span> bin2 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                    fes_slice = self.fes[bin1*bin_size:(bin1+<span class="hljs-number">1</span>)*bin_size,
                                         bin2*bin_size:(bin2+<span class="hljs-number">1</span>)*bin_size]
                    bin_min = np.min(fes_slice)
                    argmin = np.argmin(fes_slice)
                    <span class="hljs-comment"># indexes of global minimum of a bin</span>
                    bin_min_arg = np.unravel_index(np.argmin(fes_slice), fes_slice.shape)
                    <span class="hljs-comment"># indexes of that minima in the original fes (indexes +1)</span>
                    min_cv1_b = int(bin_min_arg[<span class="hljs-number">0</span>]+bin1*bin_size)
                    min_cv2_b = int(bin_min_arg[<span class="hljs-number">1</span>]+bin2*bin_size)
                    <span class="hljs-keyword">if</span> (bin_min_arg[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">0</span>]&lt;(bin_size<span class="hljs-number">-1</span>)) \
                                    <span class="hljs-keyword">and</span> (bin_min_arg[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">1</span>]&lt;(bin_size<span class="hljs-number">-1</span>)):
                        min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                        min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                        <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                            self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                  int(min_cv2_b), round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])
                        <span class="hljs-keyword">else</span>:
                            self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), \
                                                                          int(min_cv2_b), round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])))
                    <span class="hljs-keyword">else</span>:
                        around = []
                        min_cv1_b_low = min_cv1_b - <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv1_b_low == <span class="hljs-number">-1</span>:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv1_b_low = self.res - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv1_b_low = float(<span class="hljs-string">"nan"</span>)

                        min_cv1_b_high = min_cv1_b + <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv1_b_high == self.res:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv1_b_high = <span class="hljs-number">0</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv1_b_high = float(<span class="hljs-string">"nan"</span>)

                        min_cv2_b_low = min_cv2_b - <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv2_b_low == <span class="hljs-number">-1</span>:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv2_b_low = self.res - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv2_b_low = float(<span class="hljs-string">"nan"</span>)

                        min_cv2_b_high = min_cv2_b + <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv2_b_high == self.res:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv2_b_high = <span class="hljs-number">0</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv2_b_high = float(<span class="hljs-string">"nan"</span>)
                        <span class="hljs-comment">#1_b_low</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                around.append(self.fes[min_cv1_b_low, min_cv2_b_low])
                            around.append(self.fes[min_cv1_b_low,min_cv2_b])
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                around.append(self.fes[min_cv1_b_low, min_cv2_b_high])
                        <span class="hljs-comment">#1_b</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                            around.append(self.fes[min_cv1_b, min_cv2_b_low])
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                            around.append(self.fes[min_cv1_b, min_cv2_b_high])
                        <span class="hljs-comment">#1_b_high</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                around.append(self.fes[min_cv1_b_high, min_cv2_b_low])
                            around.append(self.fes[min_cv1_b_high, min_cv2_b])
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                around.append(self.fes[min_cv1_b_high, min_cv2_b_high])
                        <span class="hljs-keyword">if</span> bin_min &lt; np.min(around):
                            min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                            min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                            <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                                self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), int(min_cv2_b), \
                                                      round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])
                            <span class="hljs-keyword">else</span>:
                                self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), \
                                                                              int(min_cv2_b), round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])))
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">for</span> bin1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                <span class="hljs-keyword">for</span> bin2 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                    <span class="hljs-keyword">for</span> bin3 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, nbins):
                        fes_slice = self.fes[bin1*bin_size:(bin1+<span class="hljs-number">1</span>)*bin_size,
                                             bin2*bin_size:(bin2+<span class="hljs-number">1</span>)*bin_size, 
                                             bin3*bin_size:(bin3+<span class="hljs-number">1</span>)*bin_size]
                        bin_min = np.min(fes_slice)
                        argmin = np.argmin(fes_slice)
                        <span class="hljs-comment"># indexes of global minimum of a bin</span>
                        bin_min_arg = np.unravel_index(np.argmin(fes_slice), fes_slice.shape)
                        <span class="hljs-comment"># indexes of that minima in the original fes (indexes +1)</span>
                        min_cv1_b = int(bin_min_arg[<span class="hljs-number">0</span>]+bin1*bin_size)
                        min_cv2_b = int(bin_min_arg[<span class="hljs-number">1</span>]+bin2*bin_size)
                        min_cv3_b = int(bin_min_arg[<span class="hljs-number">2</span>]+bin3*bin_size)
                        <span class="hljs-keyword">if</span> (bin_min_arg[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">0</span>]&lt;(bin_size<span class="hljs-number">-1</span>)) \
                                        <span class="hljs-keyword">and</span> (bin_min_arg[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">1</span>]&lt;(bin_size<span class="hljs-number">-1</span>))\
                                        <span class="hljs-keyword">and</span> (bin_min_arg[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">2</span>]&lt;(bin_size<span class="hljs-number">-1</span>)):
                            min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                            min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                            min_cv3 = (((min_cv3_b+<span class="hljs-number">0.5</span>)/self.res)*(cv3max-cv3min))+cv3min
                            <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                                self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])
                            <span class="hljs-keyword">else</span>:
                                self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])))
                        <span class="hljs-keyword">else</span>:
                            around = []
                            min_cv1_b_low = min_cv1_b - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv1_b_low == <span class="hljs-number">-1</span>:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv1_b_low = self.res - <span class="hljs-number">1</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv1_b_low = float(<span class="hljs-string">"nan"</span>)

                            min_cv1_b_high = min_cv1_b + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv1_b_high == self.res:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv1_b_high = <span class="hljs-number">0</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv1_b_high = float(<span class="hljs-string">"nan"</span>)

                            min_cv2_b_low = min_cv2_b - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv2_b_low == <span class="hljs-number">-1</span>:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv2_b_low = self.res - <span class="hljs-number">1</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv2_b_low = float(<span class="hljs-string">"nan"</span>)

                            min_cv2_b_high = min_cv2_b + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv2_b_high == self.res:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv2_b_high = <span class="hljs-number">0</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv2_b_high = float(<span class="hljs-string">"nan"</span>)
                                                       
                            min_cv3_b_low = min_cv3_b - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv3_b_low == <span class="hljs-number">-1</span>:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                                    min_cv3_b_low = self.res - <span class="hljs-number">1</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv3_b_low = float(<span class="hljs-string">"nan"</span>)

                            min_cv3_b_high = min_cv3_b + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv3_b_high == self.res:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                                    min_cv3_b_high = <span class="hljs-number">0</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv3_b_high = float(<span class="hljs-string">"nan"</span>)

<span class="hljs-comment">#cv3_b</span>
                            <span class="hljs-comment">#1_b_low</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b_low,min_cv3_b])
                                around.append(self.fes[min_cv1_b_low,min_cv2_b,min_cv3_b])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b_high,min_cv3_b])
                            <span class="hljs-comment">#1_b</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                around.append(self.fes[min_cv1_b,min_cv2_b_low,min_cv3_b])
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                around.append(self.fes[min_cv1_b,min_cv2_b_high,min_cv3_b])
                            <span class="hljs-comment">#1_b_high</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b_low,min_cv3_b])
                                around.append(self.fes[min_cv1_b_high,min_cv2_b,min_cv3_b])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b_high,min_cv3_b])
                           
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv3_b_low)):
                            <span class="hljs-comment">#1_b_low</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_low,min_cv3_b_low])
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b,min_cv3_b_low])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_high,min_cv3_b_low])
                                <span class="hljs-comment">#1_b</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_low,min_cv3_b_low])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_high,min_cv3_b_low])
                                <span class="hljs-comment">#1_b_high</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_low,min_cv3_b_low])
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b,min_cv3_b_low])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_high,min_cv3_b_low])
                            
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                <span class="hljs-comment">#1_b_low</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_low,min_cv3_b_high])
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b,min_cv3_b_high])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_high,min_cv3_b_high])
                                <span class="hljs-comment">#1_b</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_low,min_cv3_b_high])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_high,min_cv3_b_high])
                                <span class="hljs-comment">#1_b_high</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_low,min_cv3_b_high])
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b,min_cv3_b_high])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_high,min_cv3_b_high])
                            
                            <span class="hljs-keyword">if</span> bin_min &lt; np.min(around):
                                min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                                min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                                min_cv3 = (((min_cv3_b+<span class="hljs-number">0.5</span>)/self.res)*(cv3max-cv3min))+cv3min
                                <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                                    self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])
                                <span class="hljs-keyword">else</span>:
                                    self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])))
        
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Fes object has unsupported number of CVs."</span>)
        
        <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
            self.minima = self.minima[self.minima[:, <span class="hljs-number">0</span>].argsort()]

        letters = list(map(chr, range(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>)))
        <span class="hljs-keyword">for</span> letter1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>):
            <span class="hljs-keyword">for</span> letter2 <span class="hljs-keyword">in</span> range(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>):
                letters.append(<span class="hljs-string">f"<span class="hljs-subst">{chr(letter1)}</span><span class="hljs-subst">{chr(letter2)}</span>"</span>)
        <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> self.minima.shape[<span class="hljs-number">1</span>] &lt; len(letters):
                self.minima = np.column_stack((letters[<span class="hljs-number">0</span>:self.minima.shape[<span class="hljs-number">0</span>]],self.minima))
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">"Error: Too many minima to assign letters."</span>)
        <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
            self.minima = np.append(<span class="hljs-string">"A"</span>, self.minima)
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
                self.minima = pd.DataFrame(np.array(self.minima), columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV1 - "</span>+self.cv1_name])
            <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
                self.minima = pd.DataFrame([self.minima], columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV1 - "</span>+self.cv1_name])
                
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
                self.minima = pd.DataFrame(np.array(self.minima), columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name])
            <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
                self.minima = pd.DataFrame([self.minima], columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name])
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
                self.minima = pd.DataFrame(np.array(self.minima), columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, <span class="hljs-string">"CV3bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name,  <span class="hljs-string">"CV3 - "</span>+self.cv3_name])
            <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
                self.minima = pd.DataFrame([self.minima], columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, <span class="hljs-string">"CV3bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name,  <span class="hljs-string">"CV3 - "</span>+self.cv3_name])
        

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span><span class="hljs-params">(self, png_name=None, contours=True, contours_spacing=<span class="hljs-number">0.0</span>, aspect = <span class="hljs-number">1.0</span>, cmap = <span class="hljs-string">"jet"</span>, 
                 energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
                 color=None, vmin = <span class="hljs-number">0</span>, vmax = None, opacity=<span class="hljs-number">0.2</span>, levels=None, show_points=True, point_size=<span class="hljs-number">4.0</span>)</span>:</span>
        <span class="hljs-string">"""
        The same function as for visualizing Fes objects, but this time 
        with the positions of local minima shown as letters on the graph.
        
        ```python
        minima.plot(png_name="minima.png")
        ```
        
        Parameters:
        
        * png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.
        
        * contours (default=True) = whether contours should be shown on 2D FES
        
        * contours_spacing (default=0.0) = when a positive number is set, it will be used as spacing for contours on 2D FES. 
                Otherwise, if contours=True, there will be five equally spaced contour levels.
        
        * aspect (default = 1.0) = aspect ratio of the graph. Works with 1D and 2D FES. 
        
        * cmap (default = "jet") = Matplotlib colormap used to color 2D or 3D FES
        
        * energy_unit (default="kJ/mol") = String, used in description of colorbar
        
        * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graphs
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        * color = string = name of color in matplotlib, if set, the color will be used for the letters. 
                If not set, the color should be automatically either black or white, 
                depending on what will be better visible on given place on FES with given colormap (for 2D FES).
        
        * vmin (default=0) = real number, lower bound for the colormap on 2D FES
        
        * vmax = real number, upper bound for the colormap on 2D FES
        
        * opacity (default=0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
        
        * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
                If not provided, default values from contours parameters will be used instead. 
        
        * show_points (default=True) = boolean, tells if points should be visualized too, instead of just the letters. Only on 3D FES. 
        
        * point_size (default=4.0) = float, sets the size of points if show_points=True
        """</span>
        
        <span class="hljs-keyword">if</span> vmax == <span class="hljs-keyword">None</span>:
            vmax = np.max(self.fes)+<span class="hljs-number">0.01</span> <span class="hljs-comment"># if the addition is smaller than 0.01, the 3d plot stops working. </span>
            
        <span class="hljs-keyword">if</span> contours_spacing == <span class="hljs-number">0.0</span>:
            contours_spacing = (vmax-vmin)/<span class="hljs-number">5.0</span>
        
        cmap = cm.get_cmap(cmap)
        
        cmap.set_over(<span class="hljs-string">"white"</span>)
        cmap.set_under(<span class="hljs-string">"white"</span>)
        
        color_set = <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">if</span> color == <span class="hljs-keyword">None</span>:
            color_set = <span class="hljs-keyword">False</span>
        
        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1per[<span class="hljs-number">0</span>]
                cv1max = self.cv1per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2per[<span class="hljs-number">0</span>]
                cv2max = self.cv2per[<span class="hljs-number">1</span>] 
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = self.cv3per[<span class="hljs-number">0</span>]
                cv3max = self.cv3per[<span class="hljs-number">1</span>] 
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
            X = np.linspace(cv1min, cv1max, self.res)
            plt.plot(X, self.fes)
            
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> color_set:
                color = <span class="hljs-string">"black"</span>
            
            ferange = np.max(self.fes) - np.min(self.fes)
            
            
            <span class="hljs-keyword">if</span> self.minima.shape[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:
                plt.text(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]), float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])+ferange*<span class="hljs-number">0.05</span>, self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                             fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                             verticalalignment=<span class="hljs-string">'bottom'</span>, c=color)
            <span class="hljs-keyword">elif</span> self.minima.shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>:
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.minima.iloc[:,<span class="hljs-number">0</span>])):
                    plt.text(float(self.minima.iloc[m,<span class="hljs-number">3</span>]), float(self.minima.iloc[m,<span class="hljs-number">1</span>])+ferange*<span class="hljs-number">0.05</span>, self.minima.iloc[m,<span class="hljs-number">0</span>],
                             fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                             verticalalignment=<span class="hljs-string">'bottom'</span>, c=color)
            
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                plt.ylabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.ylabel(ylabel, size=label_size)
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            fig = plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
            plt.imshow(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), cmap=cmap, interpolation=<span class="hljs-string">'nearest'</span>, 
                       extent=[cv1min, cv1max, cv2min, cv2max], 
                       aspect = (((cv1max-cv1min)/(cv2max-cv2min))/(aspect)),
                       vmin = vmin, vmax = vmax)
            cbar = plt.colorbar()
            cbar.set_label(energy_unit, size=label_size)

            <span class="hljs-keyword">if</span> self.minima.shape[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:
                background = cmap((float(self.minima.iloc[<span class="hljs-number">1</span>])-vmin)/(vmax-vmin))
                luma = background[<span class="hljs-number">0</span>]*<span class="hljs-number">0.2126</span>+background[<span class="hljs-number">1</span>]*<span class="hljs-number">0.7152</span>+background[<span class="hljs-number">3</span>]*<span class="hljs-number">0.0722</span>
                <span class="hljs-keyword">if</span> luma &gt; <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                    color = <span class="hljs-string">"black"</span>
                <span class="hljs-keyword">elif</span> luma &lt;= <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                    color=<span class="hljs-string">"white"</span>
                plt.text(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]), float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]), self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                             fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                             verticalalignment=<span class="hljs-string">'center'</span>, c=color)
            <span class="hljs-keyword">elif</span> self.minima.shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>:
                <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.minima.iloc[:,<span class="hljs-number">0</span>])):
                    background = cmap((float(self.minima.iloc[m,<span class="hljs-number">1</span>])-vmin)/(vmax-vmin))
                    luma = background[<span class="hljs-number">0</span>]*<span class="hljs-number">0.2126</span>+background[<span class="hljs-number">1</span>]*<span class="hljs-number">0.7152</span>+background[<span class="hljs-number">3</span>]*<span class="hljs-number">0.0722</span>
                    <span class="hljs-keyword">if</span> luma &gt; <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                        color = <span class="hljs-string">"black"</span>
                    <span class="hljs-keyword">elif</span> luma &lt;= <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                        color=<span class="hljs-string">"white"</span>
                    plt.text(float(self.minima.iloc[m,<span class="hljs-number">4</span>]), float(self.minima.iloc[m,<span class="hljs-number">5</span>]), self.minima.iloc[m,<span class="hljs-number">0</span>],
                             fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                             verticalalignment=<span class="hljs-string">'center'</span>, c=color)

            <span class="hljs-keyword">if</span> contours:
                cont = plt.contour(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), 
                         levels = np.arange(<span class="hljs-number">0</span>, (vmax + <span class="hljs-number">0.01</span>), contours_spacing), 
                         extent=[cv1min, cv1max, cv2max, cv2min], 
                         colors = <span class="hljs-string">"k"</span>)
                plt.clabel(cont, levels = np.arange(<span class="hljs-number">0</span>, (vmax + <span class="hljs-number">0.01</span>), contours_spacing))
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.xlabel(xlabel, size=label_size)
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                plt.ylabel(<span class="hljs-string">f'CV2 - <span class="hljs-subst">{self.cv2_name}</span>'</span>, size=label_size)
            <span class="hljs-keyword">else</span>:
                plt.ylabel(ylabel, size=label_size)
        
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
                xlabel = <span class="hljs-string">"CV1 - "</span> + self.cv1_name
            <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
                ylabel = <span class="hljs-string">"CV2 - "</span> + self.cv2_name
            <span class="hljs-keyword">if</span> zlabel == <span class="hljs-keyword">None</span>:
                zlabel = <span class="hljs-string">"CV3 - "</span> + self.cv3_name
            
            min_ar = self.minima.iloc[:,<span class="hljs-number">5</span>:<span class="hljs-number">8</span>].values
            min_ar = min_ar.astype(np.float32)
            min_pv = pv.PolyData(min_ar)
            grid = pv.UniformGrid(
                dimensions=(self.res, self.res, self.res),
                spacing=((cv1max-cv1min)/self.res,(cv2max-cv2min)/self.res,(cv3max-cv3min)/self.res),
                origin=(cv1min, cv2min, cv3min)
            )
            grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
            <span class="hljs-keyword">if</span> levels == <span class="hljs-keyword">None</span>:
                contours = grid.contour(np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.1</span>), contours_spacing))
            <span class="hljs-keyword">else</span>:
                contours = grid.contour(levels)
            fescolors = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(contours.points.shape[<span class="hljs-number">0</span>]):
                fescolors.append(self.fes[int((contours.points[i,<span class="hljs-number">0</span>]-cv1min)*self.res/(cv1max-cv1min)),
                                          int((contours.points[i,<span class="hljs-number">1</span>]-cv2min)*self.res/(cv2max-cv2min)),
                                          int((contours.points[i,<span class="hljs-number">2</span>]-cv3min)*self.res/(cv3max-cv3min))])
            <span class="hljs-comment">#%% Visualization</span>
            pv.set_plot_theme(<span class="hljs-string">'document'</span>)
            p = pv.Plotter()
            p.add_mesh(contours, scalars=fescolors, opacity=opacity, cmap=cmap, show_scalar_bar=<span class="hljs-keyword">False</span>, interpolate_before_map=<span class="hljs-keyword">True</span>)
            p.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
            p.add_point_labels(min_pv, self.minima.iloc[:,<span class="hljs-number">0</span>], 
                   show_points=show_points, always_visible = <span class="hljs-keyword">True</span>, 
                   point_color=<span class="hljs-string">"black"</span>, point_size=point_size, 
                   font_size=label_size, shape=<span class="hljs-keyword">None</span>)
            p.show()
            
        <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
            plt.savefig(png_name)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_gif</span><span class="hljs-params">(self, gif_name=None, cmap = <span class="hljs-string">"jet"</span>, 
                 xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
                  opacity=<span class="hljs-number">0.2</span>, levels=None, show_points=True, point_size=<span class="hljs-number">4.0</span>, frames=<span class="hljs-number">64</span>)</span>:</span>
        <span class="hljs-string">"""
        Function that generates animation of 3D FES showing different isosurfaces.
        
        ```python
        fes.make_gif(gif_name="FES.gif")
        ```
        
        Parameters:
        
        * gif_name (default="minima.gif") = String. Name of the gif that will be saved in the working directory.
        
        * cmap (default = "jet") = Matplotlib colormap used to color the 3D FES
        
        * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graph
        
        * labelsize (default = 12) = size of text in labels
        
        * image_size (default = [10,7]) = List of the width and height of the picture
        
        * opacity (default = 0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
        
        * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
                If not provided, default values from contours parameters will be used instead. 
        
        * frames (default = 64) = Number of frames the animation will be made of. 
        """</span>
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            values = np.linspace(np.min(self.fes)+<span class="hljs-number">1</span>, np.max(self.fes), num=frames)
            grid = pv.UniformGrid(
                dimensions=(self.res, self.res, self.res),
                spacing=((self.cv1max-self.cv1min)/self.res,(self.cv2max-self.cv2min)/self.res,(self.cv3max-self.cv3min)/self.res),
                origin=(self.cv1min, self.cv2min, self.cv3min),
            )
            grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
            surface = grid.contour(values[:<span class="hljs-number">1</span>])
            surfaces = [grid.contour([v]) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]
            surface = surfaces[<span class="hljs-number">0</span>].copy()
            
            pv.set_plot_theme(<span class="hljs-string">'document'</span>)
            plotter = pv.Plotter(off_screen=<span class="hljs-keyword">True</span>)
            <span class="hljs-comment"># Open a movie file</span>
            plotter.open_gif(gif_name)

            <span class="hljs-comment"># Add initial mesh</span>
            plotter.add_mesh(
                surface,
                opacity=<span class="hljs-number">0.3</span>,
                clim=grid.get_data_range(),
                show_scalar_bar=<span class="hljs-keyword">False</span>,
                cmap=<span class="hljs-string">"jet"</span>
            )
            plotter.add_mesh(grid.outline_corners(), color=<span class="hljs-string">"k"</span>)
            <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> ylabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> zlabel == <span class="hljs-keyword">None</span>:
                plotter.show_grid(xlabel=<span class="hljs-string">f"CV1 - <span class="hljs-subst">{self.cv1_name}</span>"</span>, ylabel=<span class="hljs-string">f"CV2 - <span class="hljs-subst">{self.cv2_name}</span>"</span>, zlabel=<span class="hljs-string">f"CV3 - <span class="hljs-subst">{self.cv3_name}</span>"</span>)
            <span class="hljs-keyword">else</span>:
                plotter.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
            <span class="hljs-keyword">if</span> show_points:
                min_ar = self.minima.iloc[:,<span class="hljs-number">5</span>:<span class="hljs-number">8</span>].values
                min_ar = min_ar.astype(np.float32)
                min_pv = pv.PolyData(min_ar)
                plotter.add_point_labels(min_pv, self.minima.iloc[:,<span class="hljs-number">0</span>], 
                               show_points=<span class="hljs-keyword">True</span>, always_visible = <span class="hljs-keyword">True</span>, 
                               pickable = <span class="hljs-keyword">True</span>, point_color=<span class="hljs-string">"black"</span>, 
                               point_size=<span class="hljs-number">4</span>, font_size=<span class="hljs-number">16</span>, shape=<span class="hljs-keyword">None</span>)
            plotter.set_background(<span class="hljs-string">'white'</span>)
            plotter.show(auto_close=<span class="hljs-keyword">False</span>)

            <span class="hljs-comment"># Run through each frame</span>
            <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces:
                surface.copy_from(surf)
                plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>
            <span class="hljs-comment"># Run through backwards</span>
            <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces[::<span class="hljs-number">-1</span>]:
                surface.copy_from(surf)
                plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>

            <span class="hljs-comment"># Be sure to close the plotter when finished</span>
            plotter.close()
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Error: gif_plot is only available for FES with 3 CVs."</span>)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="metadynminer.Minima.findminima"><code class="name flex">
<span>def <span class="ident">findminima</span></span>(<span>self, nbins=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal method for finding local minima on FES.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findminima</span><span class="hljs-params">(self, nbins=<span class="hljs-number">8</span>)</span>:</span>
        <span class="hljs-string">"""
        Internal method for finding local minima on FES.
        """</span>
        <span class="hljs-keyword">if</span> int(nbins) != nbins:
            nbins = int(nbins)
            print(<span class="hljs-string">f"Number of bins must be an integer, it will be set to <span class="hljs-subst">{nbins}</span>."</span>)
        <span class="hljs-keyword">if</span> self.res%nbins != <span class="hljs-number">0</span>:
            print(<span class="hljs-string">"Error: Resolution of FES must be divisible by number of bins."</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-keyword">if</span> nbins &gt; self.res/<span class="hljs-number">2</span>:
            print(<span class="hljs-string">"Error: Number of bins is too high."</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        bin_size = int(self.res/nbins)

        <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
                cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
                cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv1min = self.cv1min
                cv1max = self.cv1max 
        <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
                cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
                cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv2min = self.cv2min
                cv2max = self.cv2max 
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
                cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
                cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            <span class="hljs-keyword">else</span>:
                cv3min = self.cv3min
                cv3max = self.cv3max

        self.minima = []
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">for</span> bin1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                fes_slice = self.fes[bin1*bin_size:(bin1+<span class="hljs-number">1</span>)*bin_size]
                bin_min = np.min(fes_slice)
                argmin = np.argmin(fes_slice)
                <span class="hljs-comment"># indexes of global minimum of a bin</span>
                bin_min_arg_cv1 = int(argmin%bin_size)
                <span class="hljs-comment"># indexes of that minima in the original fes (indexes +1)</span>
                min_cv1_b = int(bin_min_arg_cv1+bin1*bin_size)
                <span class="hljs-keyword">if</span> (bin_min_arg_cv1 &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg_cv1&lt;(bin_size<span class="hljs-number">-1</span>)):
                    min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                    <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                        self.minima = np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])
                    <span class="hljs-keyword">else</span>:
                        self.minima = np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])))
                <span class="hljs-keyword">else</span>:
                    around = []
                    min_cv1_b_low = min_cv1_b - <span class="hljs-number">1</span>
                    <span class="hljs-keyword">if</span> min_cv1_b_low == <span class="hljs-number">-1</span>:
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                            min_cv1_b_low = self.res - <span class="hljs-number">1</span>
                        <span class="hljs-keyword">else</span>:
                            min_cv1_b_low = float(<span class="hljs-string">"nan"</span>)

                    min_cv1_b_high = min_cv1_b + <span class="hljs-number">1</span>
                    <span class="hljs-keyword">if</span> min_cv1_b_high == self.res:
                        <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                            min_cv1_b_high = <span class="hljs-number">0</span>
                        <span class="hljs-keyword">else</span>:
                            min_cv1_b_high = float(<span class="hljs-string">"nan"</span>)

                    <span class="hljs-comment">#1_b_low</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                        around.append(self.fes[min_cv1_b_low])
                    <span class="hljs-comment">#1_b_high</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                        around.append(self.fes[min_cv1_b_high])
                    
                    <span class="hljs-keyword">if</span> bin_min &lt; np.min(around):
                        min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                        <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                            self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])
                        <span class="hljs-keyword">else</span>:
                            self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), round(min_cv1, <span class="hljs-number">6</span>)])))
            
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">for</span> bin1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                <span class="hljs-keyword">for</span> bin2 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                    fes_slice = self.fes[bin1*bin_size:(bin1+<span class="hljs-number">1</span>)*bin_size,
                                         bin2*bin_size:(bin2+<span class="hljs-number">1</span>)*bin_size]
                    bin_min = np.min(fes_slice)
                    argmin = np.argmin(fes_slice)
                    <span class="hljs-comment"># indexes of global minimum of a bin</span>
                    bin_min_arg = np.unravel_index(np.argmin(fes_slice), fes_slice.shape)
                    <span class="hljs-comment"># indexes of that minima in the original fes (indexes +1)</span>
                    min_cv1_b = int(bin_min_arg[<span class="hljs-number">0</span>]+bin1*bin_size)
                    min_cv2_b = int(bin_min_arg[<span class="hljs-number">1</span>]+bin2*bin_size)
                    <span class="hljs-keyword">if</span> (bin_min_arg[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">0</span>]&lt;(bin_size<span class="hljs-number">-1</span>)) \
                                    <span class="hljs-keyword">and</span> (bin_min_arg[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">1</span>]&lt;(bin_size<span class="hljs-number">-1</span>)):
                        min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                        min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                        <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                            self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                  int(min_cv2_b), round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])
                        <span class="hljs-keyword">else</span>:
                            self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), \
                                                                          int(min_cv2_b), round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])))
                    <span class="hljs-keyword">else</span>:
                        around = []
                        min_cv1_b_low = min_cv1_b - <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv1_b_low == <span class="hljs-number">-1</span>:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv1_b_low = self.res - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv1_b_low = float(<span class="hljs-string">"nan"</span>)

                        min_cv1_b_high = min_cv1_b + <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv1_b_high == self.res:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv1_b_high = <span class="hljs-number">0</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv1_b_high = float(<span class="hljs-string">"nan"</span>)

                        min_cv2_b_low = min_cv2_b - <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv2_b_low == <span class="hljs-number">-1</span>:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv2_b_low = self.res - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv2_b_low = float(<span class="hljs-string">"nan"</span>)

                        min_cv2_b_high = min_cv2_b + <span class="hljs-number">1</span>
                        <span class="hljs-keyword">if</span> min_cv2_b_high == self.res:
                            <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                min_cv2_b_high = <span class="hljs-number">0</span>
                            <span class="hljs-keyword">else</span>:
                                min_cv2_b_high = float(<span class="hljs-string">"nan"</span>)
                        <span class="hljs-comment">#1_b_low</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                around.append(self.fes[min_cv1_b_low, min_cv2_b_low])
                            around.append(self.fes[min_cv1_b_low,min_cv2_b])
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                around.append(self.fes[min_cv1_b_low, min_cv2_b_high])
                        <span class="hljs-comment">#1_b</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                            around.append(self.fes[min_cv1_b, min_cv2_b_low])
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                            around.append(self.fes[min_cv1_b, min_cv2_b_high])
                        <span class="hljs-comment">#1_b_high</span>
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                around.append(self.fes[min_cv1_b_high, min_cv2_b_low])
                            around.append(self.fes[min_cv1_b_high, min_cv2_b])
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                around.append(self.fes[min_cv1_b_high, min_cv2_b_high])
                        <span class="hljs-keyword">if</span> bin_min &lt; np.min(around):
                            min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                            min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                            <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                                self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), int(min_cv2_b), \
                                                      round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])
                            <span class="hljs-keyword">else</span>:
                                self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b), \
                                                                              int(min_cv2_b), round(min_cv1, <span class="hljs-number">6</span>), round(min_cv2, <span class="hljs-number">6</span>)])))
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">for</span> bin1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                <span class="hljs-keyword">for</span> bin2 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,nbins):
                    <span class="hljs-keyword">for</span> bin3 <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, nbins):
                        fes_slice = self.fes[bin1*bin_size:(bin1+<span class="hljs-number">1</span>)*bin_size,
                                             bin2*bin_size:(bin2+<span class="hljs-number">1</span>)*bin_size, 
                                             bin3*bin_size:(bin3+<span class="hljs-number">1</span>)*bin_size]
                        bin_min = np.min(fes_slice)
                        argmin = np.argmin(fes_slice)
                        <span class="hljs-comment"># indexes of global minimum of a bin</span>
                        bin_min_arg = np.unravel_index(np.argmin(fes_slice), fes_slice.shape)
                        <span class="hljs-comment"># indexes of that minima in the original fes (indexes +1)</span>
                        min_cv1_b = int(bin_min_arg[<span class="hljs-number">0</span>]+bin1*bin_size)
                        min_cv2_b = int(bin_min_arg[<span class="hljs-number">1</span>]+bin2*bin_size)
                        min_cv3_b = int(bin_min_arg[<span class="hljs-number">2</span>]+bin3*bin_size)
                        <span class="hljs-keyword">if</span> (bin_min_arg[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">0</span>]&lt;(bin_size<span class="hljs-number">-1</span>)) \
                                        <span class="hljs-keyword">and</span> (bin_min_arg[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">1</span>]&lt;(bin_size<span class="hljs-number">-1</span>))\
                                        <span class="hljs-keyword">and</span> (bin_min_arg[<span class="hljs-number">2</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> bin_min_arg[<span class="hljs-number">2</span>]&lt;(bin_size<span class="hljs-number">-1</span>)):
                            min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                            min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                            min_cv3 = (((min_cv3_b+<span class="hljs-number">0.5</span>)/self.res)*(cv3max-cv3min))+cv3min
                            <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                                self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])
                            <span class="hljs-keyword">else</span>:
                                self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])))
                        <span class="hljs-keyword">else</span>:
                            around = []
                            min_cv1_b_low = min_cv1_b - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv1_b_low == <span class="hljs-number">-1</span>:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv1_b_low = self.res - <span class="hljs-number">1</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv1_b_low = float(<span class="hljs-string">"nan"</span>)

                            min_cv1_b_high = min_cv1_b + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv1_b_high == self.res:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv1_b_high = <span class="hljs-number">0</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv1_b_high = float(<span class="hljs-string">"nan"</span>)

                            min_cv2_b_low = min_cv2_b - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv2_b_low == <span class="hljs-number">-1</span>:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv2_b_low = self.res - <span class="hljs-number">1</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv2_b_low = float(<span class="hljs-string">"nan"</span>)

                            min_cv2_b_high = min_cv2_b + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv2_b_high == self.res:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">0</span>]:
                                    min_cv2_b_high = <span class="hljs-number">0</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv2_b_high = float(<span class="hljs-string">"nan"</span>)
                                                       
                            min_cv3_b_low = min_cv3_b - <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv3_b_low == <span class="hljs-number">-1</span>:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                                    min_cv3_b_low = self.res - <span class="hljs-number">1</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv3_b_low = float(<span class="hljs-string">"nan"</span>)

                            min_cv3_b_high = min_cv3_b + <span class="hljs-number">1</span>
                            <span class="hljs-keyword">if</span> min_cv3_b_high == self.res:
                                <span class="hljs-keyword">if</span> self.periodic[<span class="hljs-number">2</span>]:
                                    min_cv3_b_high = <span class="hljs-number">0</span>
                                <span class="hljs-keyword">else</span>:
                                    min_cv3_b_high = float(<span class="hljs-string">"nan"</span>)

<span class="hljs-comment">#cv3_b</span>
                            <span class="hljs-comment">#1_b_low</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b_low,min_cv3_b])
                                around.append(self.fes[min_cv1_b_low,min_cv2_b,min_cv3_b])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b_high,min_cv3_b])
                            <span class="hljs-comment">#1_b</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                around.append(self.fes[min_cv1_b,min_cv2_b_low,min_cv3_b])
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                around.append(self.fes[min_cv1_b,min_cv2_b_high,min_cv3_b])
                            <span class="hljs-comment">#1_b_high</span>
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b_low,min_cv3_b])
                                around.append(self.fes[min_cv1_b_high,min_cv2_b,min_cv3_b])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b_high,min_cv3_b])
                           
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv3_b_low)):
                            <span class="hljs-comment">#1_b_low</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_low,min_cv3_b_low])
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b,min_cv3_b_low])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_high,min_cv3_b_low])
                                <span class="hljs-comment">#1_b</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_low,min_cv3_b_low])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_high,min_cv3_b_low])
                                <span class="hljs-comment">#1_b_high</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_low,min_cv3_b_low])
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b,min_cv3_b_low])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_high,min_cv3_b_low])
                            
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                <span class="hljs-comment">#1_b_low</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_low)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_low,min_cv3_b_high])
                                    around.append(self.fes[min_cv1_b_low,min_cv2_b,min_cv3_b_high])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_low,min_cv2_b_high,min_cv3_b_high])
                                <span class="hljs-comment">#1_b</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_low,min_cv3_b_high])
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                    around.append(self.fes[min_cv1_b,min_cv2_b_high,min_cv3_b_high])
                                <span class="hljs-comment">#1_b_high</span>
                                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv1_b_high)):
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_low)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_low,min_cv3_b_high])
                                    around.append(self.fes[min_cv1_b_high,min_cv2_b,min_cv3_b_high])
                                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(np.isnan(min_cv2_b_high)):
                                        around.append(self.fes[min_cv1_b_high,min_cv2_b_high,min_cv3_b_high])
                            
                            <span class="hljs-keyword">if</span> bin_min &lt; np.min(around):
                                min_cv1 = (((min_cv1_b+<span class="hljs-number">0.5</span>)/self.res)*(cv1max-cv1min))+cv1min
                                min_cv2 = (((min_cv2_b+<span class="hljs-number">0.5</span>)/self.res)*(cv2max-cv2min))+cv2min
                                min_cv3 = (((min_cv3_b+<span class="hljs-number">0.5</span>)/self.res)*(cv3max-cv3min))+cv3min
                                <span class="hljs-keyword">if</span> len(self.minima) == <span class="hljs-number">0</span>:
                                    self.minima=np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])
                                <span class="hljs-keyword">else</span>:
                                    self.minima=np.vstack((self.minima, np.array([round(bin_min, <span class="hljs-number">6</span>), int(min_cv1_b),\
                                                      int(min_cv2_b), int(min_cv3_b), round(min_cv1, <span class="hljs-number">6</span>), \
                                                      round(min_cv2, <span class="hljs-number">6</span>), round(min_cv3, <span class="hljs-number">6</span>)])))
        
        <span class="hljs-keyword">else</span>:
            print(<span class="hljs-string">"Fes object has unsupported number of CVs."</span>)
        
        <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
            self.minima = self.minima[self.minima[:, <span class="hljs-number">0</span>].argsort()]

        letters = list(map(chr, range(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>)))
        <span class="hljs-keyword">for</span> letter1 <span class="hljs-keyword">in</span> range(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>):
            <span class="hljs-keyword">for</span> letter2 <span class="hljs-keyword">in</span> range(<span class="hljs-number">65</span>, <span class="hljs-number">91</span>):
                letters.append(<span class="hljs-string">f"<span class="hljs-subst">{chr(letter1)}</span><span class="hljs-subst">{chr(letter2)}</span>"</span>)
        <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> self.minima.shape[<span class="hljs-number">1</span>] &lt; len(letters):
                self.minima = np.column_stack((letters[<span class="hljs-number">0</span>:self.minima.shape[<span class="hljs-number">0</span>]],self.minima))
            <span class="hljs-keyword">else</span>:
                print(<span class="hljs-string">"Error: Too many minima to assign letters."</span>)
        <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
            self.minima = np.append(<span class="hljs-string">"A"</span>, self.minima)
        
        <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
            <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
                self.minima = pd.DataFrame(np.array(self.minima), columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV1 - "</span>+self.cv1_name])
            <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
                self.minima = pd.DataFrame([self.minima], columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV1 - "</span>+self.cv1_name])
                
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
            <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
                self.minima = pd.DataFrame(np.array(self.minima), columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name])
            <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
                self.minima = pd.DataFrame([self.minima], columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name])
        <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
            <span class="hljs-keyword">if</span> len(self.minima.shape)&gt;<span class="hljs-number">1</span>:
                self.minima = pd.DataFrame(np.array(self.minima), columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, <span class="hljs-string">"CV3bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name,  <span class="hljs-string">"CV3 - "</span>+self.cv3_name])
            <span class="hljs-keyword">elif</span> len(self.minima.shape) == <span class="hljs-number">1</span>:
                self.minima = pd.DataFrame([self.minima], columns = [<span class="hljs-string">"Minimum"</span>, <span class="hljs-string">"free energy"</span>, <span class="hljs-string">"CV1bin"</span>, <span class="hljs-string">"CV2bin"</span>, <span class="hljs-string">"CV3bin"</span>, 
                                                               <span class="hljs-string">"CV1 - "</span>+self.cv1_name, <span class="hljs-string">"CV2 - "</span>+self.cv2_name,  <span class="hljs-string">"CV3 - "</span>+self.cv3_name])</code></pre>
</details>
</dd>
<dt id="metadynminer.Minima.make_gif"><code class="name flex">
<span>def <span class="ident">make_gif</span></span>(<span>self, gif_name=None, cmap='jet', xlabel=None, ylabel=None, zlabel=None, label_size=12, image_size=[10, 7], opacity=0.2, levels=None, show_points=True, point_size=4.0, frames=64)</span>
</code></dt>
<dd>
<div class="desc"><p>Function that generates animation of 3D FES showing different isosurfaces.</p>
<pre><code class="language-python hljs">fes.make_gif(gif_name=<span class="hljs-string">"FES.gif"</span>)
</code></pre>
<p>Parameters:</p>
<ul>
<li>
<p>gif_name (default="minima.gif") = String. Name of the gif that will be saved in the working directory.</p>
</li>
<li>
<p>cmap (default = "jet") = Matplotlib colormap used to color the 3D FES</p>
</li>
<li>
<p>xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graph</p>
</li>
<li>
<p>labelsize (default = 12) = size of text in labels</p>
</li>
<li>
<p>image_size (default = [10,7]) = List of the width and height of the picture</p>
</li>
<li>
<p>opacity (default = 0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES</p>
</li>
<li>
<p>levels = Here you can specify list of free energy values for isosurfaces on 3D FES.
If not provided, default values from contours parameters will be used instead. </p>
</li>
<li>
<p>frames (default = 64) = Number of frames the animation will be made of.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_gif</span><span class="hljs-params">(self, gif_name=None, cmap = <span class="hljs-string">"jet"</span>, 
             xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
              opacity=<span class="hljs-number">0.2</span>, levels=None, show_points=True, point_size=<span class="hljs-number">4.0</span>, frames=<span class="hljs-number">64</span>)</span>:</span>
    <span class="hljs-string">"""
    Function that generates animation of 3D FES showing different isosurfaces.
    
    ```python
    fes.make_gif(gif_name="FES.gif")
    ```
    
    Parameters:
    
    * gif_name (default="minima.gif") = String. Name of the gif that will be saved in the working directory.
    
    * cmap (default = "jet") = Matplotlib colormap used to color the 3D FES
    
    * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graph
    
    * labelsize (default = 12) = size of text in labels
    
    * image_size (default = [10,7]) = List of the width and height of the picture
    
    * opacity (default = 0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
    
    * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
            If not provided, default values from contours parameters will be used instead. 
    
    * frames (default = 64) = Number of frames the animation will be made of. 
    """</span>
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
        values = np.linspace(np.min(self.fes)+<span class="hljs-number">1</span>, np.max(self.fes), num=frames)
        grid = pv.UniformGrid(
            dimensions=(self.res, self.res, self.res),
            spacing=((self.cv1max-self.cv1min)/self.res,(self.cv2max-self.cv2min)/self.res,(self.cv3max-self.cv3min)/self.res),
            origin=(self.cv1min, self.cv2min, self.cv3min),
        )
        grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
        surface = grid.contour(values[:<span class="hljs-number">1</span>])
        surfaces = [grid.contour([v]) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> values]
        surface = surfaces[<span class="hljs-number">0</span>].copy()
        
        pv.set_plot_theme(<span class="hljs-string">'document'</span>)
        plotter = pv.Plotter(off_screen=<span class="hljs-keyword">True</span>)
        <span class="hljs-comment"># Open a movie file</span>
        plotter.open_gif(gif_name)

        <span class="hljs-comment"># Add initial mesh</span>
        plotter.add_mesh(
            surface,
            opacity=<span class="hljs-number">0.3</span>,
            clim=grid.get_data_range(),
            show_scalar_bar=<span class="hljs-keyword">False</span>,
            cmap=<span class="hljs-string">"jet"</span>
        )
        plotter.add_mesh(grid.outline_corners(), color=<span class="hljs-string">"k"</span>)
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> ylabel == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> zlabel == <span class="hljs-keyword">None</span>:
            plotter.show_grid(xlabel=<span class="hljs-string">f"CV1 - <span class="hljs-subst">{self.cv1_name}</span>"</span>, ylabel=<span class="hljs-string">f"CV2 - <span class="hljs-subst">{self.cv2_name}</span>"</span>, zlabel=<span class="hljs-string">f"CV3 - <span class="hljs-subst">{self.cv3_name}</span>"</span>)
        <span class="hljs-keyword">else</span>:
            plotter.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
        <span class="hljs-keyword">if</span> show_points:
            min_ar = self.minima.iloc[:,<span class="hljs-number">5</span>:<span class="hljs-number">8</span>].values
            min_ar = min_ar.astype(np.float32)
            min_pv = pv.PolyData(min_ar)
            plotter.add_point_labels(min_pv, self.minima.iloc[:,<span class="hljs-number">0</span>], 
                           show_points=<span class="hljs-keyword">True</span>, always_visible = <span class="hljs-keyword">True</span>, 
                           pickable = <span class="hljs-keyword">True</span>, point_color=<span class="hljs-string">"black"</span>, 
                           point_size=<span class="hljs-number">4</span>, font_size=<span class="hljs-number">16</span>, shape=<span class="hljs-keyword">None</span>)
        plotter.set_background(<span class="hljs-string">'white'</span>)
        plotter.show(auto_close=<span class="hljs-keyword">False</span>)

        <span class="hljs-comment"># Run through each frame</span>
        <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces:
            surface.copy_from(surf)
            plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>
        <span class="hljs-comment"># Run through backwards</span>
        <span class="hljs-keyword">for</span> surf <span class="hljs-keyword">in</span> surfaces[::<span class="hljs-number">-1</span>]:
            surface.copy_from(surf)
            plotter.write_frame()  <span class="hljs-comment"># Write this frame</span>

        <span class="hljs-comment"># Be sure to close the plotter when finished</span>
        plotter.close()
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">"Error: gif_plot is only available for FES with 3 CVs."</span>)</code></pre>
</details>
</dd>
<dt id="metadynminer.Minima.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, png_name=None, contours=True, contours_spacing=0.0, aspect=1.0, cmap='jet', energy_unit='kJ/mol', xlabel=None, ylabel=None, zlabel=None, label_size=12, image_size=[10, 7], color=None, vmin=0, vmax=None, opacity=0.2, levels=None, show_points=True, point_size=4.0)</span>
</code></dt>
<dd>
<div class="desc"><p>The same function as for visualizing Fes objects, but this time
with the positions of local minima shown as letters on the graph.</p>
<pre><code class="language-python hljs">minima.plot(png_name=<span class="hljs-string">"minima.png"</span>)
</code></pre>
<p>Parameters:</p>
<ul>
<li>
<p>png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.</p>
</li>
<li>
<p>contours (default=True) = whether contours should be shown on 2D FES</p>
</li>
<li>
<p>contours_spacing (default=0.0) = when a positive number is set, it will be used as spacing for contours on 2D FES.
Otherwise, if contours=True, there will be five equally spaced contour levels.</p>
</li>
<li>
<p>aspect (default = 1.0) = aspect ratio of the graph. Works with 1D and 2D FES. </p>
</li>
<li>
<p>cmap (default = "jet") = Matplotlib colormap used to color 2D or 3D FES</p>
</li>
<li>
<p>energy_unit (default="kJ/mol") = String, used in description of colorbar</p>
</li>
<li>
<p>xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graphs</p>
</li>
<li>
<p>labelsize (default = 12) = size of text in labels</p>
</li>
<li>
<p>image_size (default = [10,7]) = List of the width and height of the picture</p>
</li>
<li>
<p>color = string = name of color in matplotlib, if set, the color will be used for the letters.
If not set, the color should be automatically either black or white,
depending on what will be better visible on given place on FES with given colormap (for 2D FES).</p>
</li>
<li>
<p>vmin (default=0) = real number, lower bound for the colormap on 2D FES</p>
</li>
<li>
<p>vmax = real number, upper bound for the colormap on 2D FES</p>
</li>
<li>
<p>opacity (default=0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES</p>
</li>
<li>
<p>levels = Here you can specify list of free energy values for isosurfaces on 3D FES.
If not provided, default values from contours parameters will be used instead. </p>
</li>
<li>
<p>show_points (default=True) = boolean, tells if points should be visualized too, instead of just the letters. Only on 3D FES. </p>
</li>
<li>
<p>point_size (default=4.0) = float, sets the size of points if show_points=True</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span><span class="hljs-params">(self, png_name=None, contours=True, contours_spacing=<span class="hljs-number">0.0</span>, aspect = <span class="hljs-number">1.0</span>, cmap = <span class="hljs-string">"jet"</span>, 
             energy_unit=<span class="hljs-string">"kJ/mol"</span>, xlabel=None, ylabel=None, zlabel=None, label_size=<span class="hljs-number">12</span>, image_size=[<span class="hljs-number">10</span>,<span class="hljs-number">7</span>], 
             color=None, vmin = <span class="hljs-number">0</span>, vmax = None, opacity=<span class="hljs-number">0.2</span>, levels=None, show_points=True, point_size=<span class="hljs-number">4.0</span>)</span>:</span>
    <span class="hljs-string">"""
    The same function as for visualizing Fes objects, but this time 
    with the positions of local minima shown as letters on the graph.
    
    ```python
    minima.plot(png_name="minima.png")
    ```
    
    Parameters:
    
    * png_name = String. If this parameter is supplied, the picture of FES will be saved under this name to the current working directory.
    
    * contours (default=True) = whether contours should be shown on 2D FES
    
    * contours_spacing (default=0.0) = when a positive number is set, it will be used as spacing for contours on 2D FES. 
            Otherwise, if contours=True, there will be five equally spaced contour levels.
    
    * aspect (default = 1.0) = aspect ratio of the graph. Works with 1D and 2D FES. 
    
    * cmap (default = "jet") = Matplotlib colormap used to color 2D or 3D FES
    
    * energy_unit (default="kJ/mol") = String, used in description of colorbar
    
    * xlabel, ylabel, zlabel = Strings, if provided, they will be used as labels for the graphs
    
    * labelsize (default = 12) = size of text in labels
    
    * image_size (default = [10,7]) = List of the width and height of the picture
    
    * color = string = name of color in matplotlib, if set, the color will be used for the letters. 
            If not set, the color should be automatically either black or white, 
            depending on what will be better visible on given place on FES with given colormap (for 2D FES).
    
    * vmin (default=0) = real number, lower bound for the colormap on 2D FES
    
    * vmax = real number, upper bound for the colormap on 2D FES
    
    * opacity (default=0.2) = number between 0 and 1, is the opacity of isosurfaces of 3D FES
    
    * levels = Here you can specify list of free energy values for isosurfaces on 3D FES. 
            If not provided, default values from contours parameters will be used instead. 
    
    * show_points (default=True) = boolean, tells if points should be visualized too, instead of just the letters. Only on 3D FES. 
    
    * point_size (default=4.0) = float, sets the size of points if show_points=True
    """</span>
    
    <span class="hljs-keyword">if</span> vmax == <span class="hljs-keyword">None</span>:
        vmax = np.max(self.fes)+<span class="hljs-number">0.01</span> <span class="hljs-comment"># if the addition is smaller than 0.01, the 3d plot stops working. </span>
        
    <span class="hljs-keyword">if</span> contours_spacing == <span class="hljs-number">0.0</span>:
        contours_spacing = (vmax-vmin)/<span class="hljs-number">5.0</span>
    
    cmap = cm.get_cmap(cmap)
    
    cmap.set_over(<span class="hljs-string">"white"</span>)
    cmap.set_under(<span class="hljs-string">"white"</span>)
    
    color_set = <span class="hljs-keyword">True</span>
    <span class="hljs-keyword">if</span> color == <span class="hljs-keyword">None</span>:
        color_set = <span class="hljs-keyword">False</span>
    
    <span class="hljs-keyword">if</span> self.cvs &gt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">0</span>]:
            cv1min = self.cv1min - (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
            cv1max = self.cv1max + (self.cv1max-self.cv1min)*<span class="hljs-number">0.15</span>
        <span class="hljs-keyword">else</span>:
            cv1min = self.cv1per[<span class="hljs-number">0</span>]
            cv1max = self.cv1per[<span class="hljs-number">1</span>] 
    <span class="hljs-keyword">if</span> self.cvs &gt;=<span class="hljs-number">2</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">1</span>]:
            cv2min = self.cv2min - (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
            cv2max = self.cv2max + (self.cv2max-self.cv2min)*<span class="hljs-number">0.15</span>
        <span class="hljs-keyword">else</span>:
            cv2min = self.cv2per[<span class="hljs-number">0</span>]
            cv2max = self.cv2per[<span class="hljs-number">1</span>] 
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.periodic[<span class="hljs-number">2</span>]:
            cv3min = self.cv3min - (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
            cv3max = self.cv3max + (self.cv3max-self.cv3min)*<span class="hljs-number">0.15</span>
        <span class="hljs-keyword">else</span>:
            cv3min = self.cv3per[<span class="hljs-number">0</span>]
            cv3max = self.cv3per[<span class="hljs-number">1</span>] 
    
    <span class="hljs-keyword">if</span> self.cvs == <span class="hljs-number">1</span>:
        plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
        X = np.linspace(cv1min, cv1max, self.res)
        plt.plot(X, self.fes)
        
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> color_set:
            color = <span class="hljs-string">"black"</span>
        
        ferange = np.max(self.fes) - np.min(self.fes)
        
        
        <span class="hljs-keyword">if</span> self.minima.shape[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:
            plt.text(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]), float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])+ferange*<span class="hljs-number">0.05</span>, self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                         fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                         verticalalignment=<span class="hljs-string">'bottom'</span>, c=color)
        <span class="hljs-keyword">elif</span> self.minima.shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>:
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.minima.iloc[:,<span class="hljs-number">0</span>])):
                plt.text(float(self.minima.iloc[m,<span class="hljs-number">3</span>]), float(self.minima.iloc[m,<span class="hljs-number">1</span>])+ferange*<span class="hljs-number">0.05</span>, self.minima.iloc[m,<span class="hljs-number">0</span>],
                         fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                         verticalalignment=<span class="hljs-string">'bottom'</span>, c=color)
        
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.xlabel(xlabel, size=label_size)
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            plt.ylabel(<span class="hljs-string">f'free energy (<span class="hljs-subst">{energy_unit}</span>)'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.ylabel(ylabel, size=label_size)
        
    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">2</span>:
        fig = plt.figure(figsize=(image_size[<span class="hljs-number">0</span>],image_size[<span class="hljs-number">1</span>]))
        plt.imshow(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), cmap=cmap, interpolation=<span class="hljs-string">'nearest'</span>, 
                   extent=[cv1min, cv1max, cv2min, cv2max], 
                   aspect = (((cv1max-cv1min)/(cv2max-cv2min))/(aspect)),
                   vmin = vmin, vmax = vmax)
        cbar = plt.colorbar()
        cbar.set_label(energy_unit, size=label_size)

        <span class="hljs-keyword">if</span> self.minima.shape[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>:
            background = cmap((float(self.minima.iloc[<span class="hljs-number">1</span>])-vmin)/(vmax-vmin))
            luma = background[<span class="hljs-number">0</span>]*<span class="hljs-number">0.2126</span>+background[<span class="hljs-number">1</span>]*<span class="hljs-number">0.7152</span>+background[<span class="hljs-number">3</span>]*<span class="hljs-number">0.0722</span>
            <span class="hljs-keyword">if</span> luma &gt; <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                color = <span class="hljs-string">"black"</span>
            <span class="hljs-keyword">elif</span> luma &lt;= <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                color=<span class="hljs-string">"white"</span>
            plt.text(float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">4</span>]), float(self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]), self.minima.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
                         fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                         verticalalignment=<span class="hljs-string">'center'</span>, c=color)
        <span class="hljs-keyword">elif</span> self.minima.shape[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>:
            <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(self.minima.iloc[:,<span class="hljs-number">0</span>])):
                background = cmap((float(self.minima.iloc[m,<span class="hljs-number">1</span>])-vmin)/(vmax-vmin))
                luma = background[<span class="hljs-number">0</span>]*<span class="hljs-number">0.2126</span>+background[<span class="hljs-number">1</span>]*<span class="hljs-number">0.7152</span>+background[<span class="hljs-number">3</span>]*<span class="hljs-number">0.0722</span>
                <span class="hljs-keyword">if</span> luma &gt; <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                    color = <span class="hljs-string">"black"</span>
                <span class="hljs-keyword">elif</span> luma &lt;= <span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> color_set:
                    color=<span class="hljs-string">"white"</span>
                plt.text(float(self.minima.iloc[m,<span class="hljs-number">4</span>]), float(self.minima.iloc[m,<span class="hljs-number">5</span>]), self.minima.iloc[m,<span class="hljs-number">0</span>],
                         fontsize=label_size, horizontalalignment=<span class="hljs-string">'center'</span>,
                         verticalalignment=<span class="hljs-string">'center'</span>, c=color)

        <span class="hljs-keyword">if</span> contours:
            cont = plt.contour(np.rot90(self.fes, axes=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)), 
                     levels = np.arange(<span class="hljs-number">0</span>, (vmax + <span class="hljs-number">0.01</span>), contours_spacing), 
                     extent=[cv1min, cv1max, cv2max, cv2min], 
                     colors = <span class="hljs-string">"k"</span>)
            plt.clabel(cont, levels = np.arange(<span class="hljs-number">0</span>, (vmax + <span class="hljs-number">0.01</span>), contours_spacing))
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            plt.xlabel(<span class="hljs-string">f'CV1 - <span class="hljs-subst">{self.cv1_name}</span>'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.xlabel(xlabel, size=label_size)
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            plt.ylabel(<span class="hljs-string">f'CV2 - <span class="hljs-subst">{self.cv2_name}</span>'</span>, size=label_size)
        <span class="hljs-keyword">else</span>:
            plt.ylabel(ylabel, size=label_size)
    
    <span class="hljs-keyword">elif</span> self.cvs == <span class="hljs-number">3</span>:
        <span class="hljs-keyword">if</span> xlabel == <span class="hljs-keyword">None</span>:
            xlabel = <span class="hljs-string">"CV1 - "</span> + self.cv1_name
        <span class="hljs-keyword">if</span> ylabel == <span class="hljs-keyword">None</span>:
            ylabel = <span class="hljs-string">"CV2 - "</span> + self.cv2_name
        <span class="hljs-keyword">if</span> zlabel == <span class="hljs-keyword">None</span>:
            zlabel = <span class="hljs-string">"CV3 - "</span> + self.cv3_name
        
        min_ar = self.minima.iloc[:,<span class="hljs-number">5</span>:<span class="hljs-number">8</span>].values
        min_ar = min_ar.astype(np.float32)
        min_pv = pv.PolyData(min_ar)
        grid = pv.UniformGrid(
            dimensions=(self.res, self.res, self.res),
            spacing=((cv1max-cv1min)/self.res,(cv2max-cv2min)/self.res,(cv3max-cv3min)/self.res),
            origin=(cv1min, cv2min, cv3min)
        )
        grid[<span class="hljs-string">"vol"</span>] = self.fes.ravel(order=<span class="hljs-string">"F"</span>)
        <span class="hljs-keyword">if</span> levels == <span class="hljs-keyword">None</span>:
            contours = grid.contour(np.arange(<span class="hljs-number">0</span>, (vmax - <span class="hljs-number">0.1</span>), contours_spacing))
        <span class="hljs-keyword">else</span>:
            contours = grid.contour(levels)
        fescolors = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(contours.points.shape[<span class="hljs-number">0</span>]):
            fescolors.append(self.fes[int((contours.points[i,<span class="hljs-number">0</span>]-cv1min)*self.res/(cv1max-cv1min)),
                                      int((contours.points[i,<span class="hljs-number">1</span>]-cv2min)*self.res/(cv2max-cv2min)),
                                      int((contours.points[i,<span class="hljs-number">2</span>]-cv3min)*self.res/(cv3max-cv3min))])
        <span class="hljs-comment">#%% Visualization</span>
        pv.set_plot_theme(<span class="hljs-string">'document'</span>)
        p = pv.Plotter()
        p.add_mesh(contours, scalars=fescolors, opacity=opacity, cmap=cmap, show_scalar_bar=<span class="hljs-keyword">False</span>, interpolate_before_map=<span class="hljs-keyword">True</span>)
        p.show_grid(xlabel=xlabel, ylabel=ylabel, zlabel=zlabel)
        p.add_point_labels(min_pv, self.minima.iloc[:,<span class="hljs-number">0</span>], 
               show_points=show_points, always_visible = <span class="hljs-keyword">True</span>, 
               point_color=<span class="hljs-string">"black"</span>, point_size=point_size, 
               font_size=label_size, shape=<span class="hljs-keyword">None</span>)
        p.show()
        
    <span class="hljs-keyword">if</span> png_name != <span class="hljs-keyword">None</span>:
        plt.savefig(png_name)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="metadynminer.FEProfile" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.FEProfile">FEProfile</a></code></h4>
<ul class="">
<li><code><a title="metadynminer.FEProfile.makefeprofile" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.FEProfile.makefeprofile">makefeprofile</a></code></li>
<li><code><a title="metadynminer.FEProfile.plot" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.FEProfile.plot">plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="metadynminer.Fes" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Fes">Fes</a></code></h4>
<ul class="">
<li><code><a title="metadynminer.Fes.make_gif" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Fes.make_gif">make_gif</a></code></li>
<li><code><a title="metadynminer.Fes.plot" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Fes.plot">plot</a></code></li>
<li><code><a title="metadynminer.Fes.removeCV" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Fes.removeCV">removeCV</a></code></li>
<li><code><a title="metadynminer.Fes.surface_plot" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Fes.surface_plot">surface_plot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="metadynminer.Hills" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Hills">Hills</a></code></h4>
<ul class="">
<li><code><a title="metadynminer.Hills.plot_heights" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Hills.plot_heights">plot_heights</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="metadynminer.Minima" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Minima">Minima</a></code></h4>
<ul class="">
<li><code><a title="metadynminer.Minima.findminima" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Minima.findminima">findminima</a></code></li>
<li><code><a title="metadynminer.Minima.make_gif" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Minima.make_gif">make_gif</a></code></li>
<li><code><a title="metadynminer.Minima.plot" href="file:///home/beranekj/pytadynminer/metadynminer/metadynminer.py/doc/metadynminer/index.html#metadynminer.Minima.plot">plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="./metadynminer API documentation_files/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>

</body></html>